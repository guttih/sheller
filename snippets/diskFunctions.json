{
    "Checks if a file is found": {
        "prefix": "File exists",
        "body": [
          "if test -f \"${1:filename.txt}\"",
          "then",
          "    ${2:echo \"File exists\"}",
          "else",
          "    ${3:echo \"File does not exist\"}",
          "fi",
          ""
        ],
        "description": "Checks if a file is found"
      }
      ,
    "Checks if a directory is found": {
      "prefix": "Dir exists",
      "body": [
        "if test -d \"${1:~/dirname}\"",
        "then",
        "    ${2:echo \"Directory exists\"}",
        "else",
        "    ${3:echo \"Directory does not exist\"}",
        "fi",
        ""
      ],
      "description": "Checks if a Directory is found"
    },
    "Iterate files in directory": {
      "prefix": "List files",
      "body": [
        "for FILE in ${1:*.sh}; do ",
        "    if [ -f \"\\$FILE\" ]; then",
        "        ${2:echo -e \"File name: \\$FILE\";} ",
        "    fi",
        "done",
        ""
      ],
      "description": "Walk through each file name in a directory"
    },
    "Iterate only directories in directory": {
      "prefix": "List dirs",
      "body": [
        "for DIR in ${1:*/}; do ",
        "    if [ -d \"\\$DIR\" ]; then",
        "        ${2:echo -e \"Directory: \\$DIR\";} ",
        "    fi",
        "done",
        ""
      ],
      "description": "Walk through each sub-directory name in a directory"
    },
    "Iterate files in directory recursive": {
      "prefix": "List files recursive",
      "body": [
        "find . -type f ${1|-name '*', -name '*.txt'|} -print0 | ",
        "while IFS= read -r -d '' FILE; do",
        "    printf '%s\\n' \"\\$FILE\"",
        "done",
        ""
      ],
      "description": "Iterate file names in directory recursive. That is, walking through sub-directories also."
    },
    "Iterate files in directory recursive regex": {
      "prefix": "List files recursive reg",
      "body": [
        "find . -type f -iregex '.*\\.\\(txt\\|}doc\\|sh\\)\\$' -print0 | ",
        "while IFS= read -r -d '' FILE; do",
        "${1|    printf '%s\\n' \"$FILE\",    printf 'Path:%-30s\\tName:\"%-30s\"\\n' \"$(dirname \"$FILE\")\" \"$(basename \"$FILE\")\"|}",
        "done",
        ""
      ],
      "description": "Iterate file names in directory recursively using regex.  That is, walking through sub-directories also."
    },
    "Iterate directories in directory": {
      "prefix": "List dirs recursive",
      "body": [
        "find . -type d -name ${1:'*'} -print0 | ",
        "while IFS= read -r -d '' DIR; do",
        "    printf '%s\\n' \"\\$DIR\"",
        "done",
        ""
      ],
      "description": "Iterate directory names in directory recursively.  That is, walking through sub-directories also."
    },
    "Compare file names in two directories": {
      "prefix": "compare filenames in dir",
      "body": [
        "#Function: compareFilenamesInDirectory()",
        "#",
        "#Brief: Compares file names in two directories and prints out file names",
        "#",
        "#Argument 1(\\$1): (Optional) [-matching] (default) Print filenames that exit in both directories.",
        "#                           [-missing]            Print filenames that only exits in First directory.",
        "#                           If this argument is skipped then -matching is used.",
        "#Argument 2(\\$2): Dir1, first directory to compare",
        "#Argument 3(\\$3): Dir2, second directory to be compared with Dir1",
        "#   # Example which searches for all files existing in current directory and are missing in \"/bin\"",
        "#   compareFilenamesInDirectory -missing \".\" \"/bin\"",
        "compareFilenamesInDirectory() {",
        "    declare OPTION",
        "    if [ \\$# -eq 3 ]; then",
        "        if [[ \"\\$1\" != \"-missing\" && \"\\$1\" != \"-matching\" && \"\\$1\" != \"\" ]]; then",
        "            echo \"Invalid parameter \\\"\\$1\\\"\"",
        "            return 1",
        "        fi",
        "        OPTION=\\$1",
        "        shift",
        "    fi",
        "    if [ \\$# -ne 2 ]; then",
        "        echo \"Invalid number of parameters\"",
        "        return 1",
        "    fi",
        "    declare NAME",
        "    if ! test -d \"\\$1\"; then",
        "        echo \"Error: Directory: \\\"\\$1\\\" does not exist\"",
        "        return 1",
        "    fi",
        "    if ! test -d \"\\$2\"; then",
        "        echo \"Error: Directory: \\\"\\$2\\\" does not exist\"",
        "        return 1",
        "    fi",
        "    for FILE in \"\\$1\"/*; do",
        "        if [ -f \"\\$FILE\" ]; then",
        "            NAME=\\$(echo \\$(basename \"\\$FILE\"))",
        "            if [ \"\\$OPTION\" = \"-missing\" ]; then",
        "                if ! test -f \"\\$2\"/\\$NAME; then",
        "                    echo \"\\$NAME\"",
        "                fi",
        "            else",
        "                if test -f \"\\$2\"/\\$NAME; then",
        "                    echo \"\\$NAME\"",
        "                fi",
        "            fi",
        "        fi",
        "    done",
        "}\n"
      ],
      "description": "Compare file names in two directories and prints out matching or missing file names"
    },
    "Script directory": {
      "prefix": "Get script dir",
      "body": [
          "#Function: getScriptPath()",
          "#",
          "#Brief: Gets the path to this script",
          "#",
          "getScriptPath(){",
          "    echo \"\\$( cd \"\\$( dirname \"\\${BASH_SOURCE[0]}\" )\" && pwd )\"",
          "}",
          "",
          "DIR=\\$(getScriptPath)",
          "echo \"Path to this script is \\$DIR\"\n"
      ],
      "description": "Get path to the the current bash file"
  },
  "Script Name": {
    "prefix": "Get script name",
    "body": [
      "#Function: getFileName()",
      "#",
      "#Brief: Extracts name of file",
      "#",
      "#Argument 1(\\$1): filename or dir and filename",
      "getFileName(){",
      "    if [ \\$# -ne 1 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
      "    echo \"\\$( basename \"\\$1\" )\"",
      "}",
      "",
      "FILE=\\${BASH_SOURCE[0]}",
      "NAME=\\$(getFileName \\$FILE)",
      "echo \"File name: \\$NAME\"",
      ""
    ],
    "description": "Get name of current script"
},
"Extract filename": {
  "prefix": "Get file name",
  "body": [
    "#Function: getFileName()",
    "#",
    "#Brief: Extracts name of file",
    "#",
    "#Argument 1(\\$1): filename or dir and filename",
    "getFileName(){",
    "    if [ \\$# -ne 1 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
    "    echo \"\\$( basename \"\\$1\" )\"",
    "}",
    "",
    "FILE=\"/c/stuff/me.txt\"",
    "NAME=\\$(getFileName \\$FILE)",
    "echo \"File name: \\$NAME\"",
    ""
  ],
  "description": "Extracts filename name from a file path"
},
"Extract file directory": {
  "prefix": "Get file directory",
  "body": [
    "#Function: getFileDirectory()",
    "#",
    "#Brief: Extracts the path from a file path and name",
    "#",
    "getFileDirectory(){",
    "    if [ \\$# -ne 1 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
    "    echo \"\\$( dirname \"\\$1\" )\"",
    "}",
    "",
    "FILE=\"/c/stuff/me.txt\"",
    "DIR=\\$(getFileDirectory \\$FILE )",
    "echo \"Directory: \\$DIR\"\n"
  ],
  "description": "Extracts directory from a file path."
},
"Extract file extension": {
  "prefix": "Get file extension",
  "body": [
    "#Function: getFileExtension()",
    "#",
    "#Brief: Extracts file extension from a file path.",
    "#",
    "#Argument 1(\\$1): Describe argument 1",
    "getFileExtension(){",
    "    if [ \\$# -ne 1 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
    "    echo \"\\${1##*.}\"",
      "}",
      "",
      "FILE=\"/c/stuff/me.txt\"",
      "EXTENSION=\\$(getFileExtension \\$FILE )",
      "echo \"File extension is \\$EXTENSION\"\n"
  ],
  "description": " Extract file extension from a file path."
},
"Read on line at a time": {
  "prefix": "read text file",
  "body": [
      "while read line",
      "    do echo \"Line \\\\\"\\$line\\\\\"\"",
      "done < \"textfile.txt\""
  ],
  "description": "Read a text file one line at a time"
},
"Read a value from a ini file": {
  "prefix": ["ini file get value","ini file read value", "iniGetSectionKeyValue", "getIniSectionKeyValue"],
  "body": [
    "#Function: getSectionKeyValue()",
    "#",
    "#Brief: Gets the value of a key(variable name) under specified section in a ini file and prints it to the terminal",
    "#",
    "#Argument 1(\\$1): File path",
    "#Argument 2(\\$2): Section name",
    "#Argument 3(\\$3): Key name",
    "#Returns       : on success 0 on error ! null",
    "#Example:",
    "#     VALUE=\\$(getSectionKeyValue \"settings.ini\" \"section2\" \"keyName\" )",
    "#     if  [ \\$? -eq \"0\" ]; then ",
    "#         if [[ -z \\$VALUE ]]; then",
    "#             echo \"Value not found, or i'ts value is empty.\"",
    "#         else",
    "#             echo \"Got the value: \\\\\"\\$VALUE\\\\\"\"",
    "#         fi",
    "#     else ",
    "#         echo \"Invalid parameters\"; ",
    "#     fi",
    "getSectionKeyValue(){",
    "    declare file=\\$1",
    "    declare section=\\$2",
    "    declare key=\\$3",
    "    ",
    "    if [ \\$# -ne 3 ];                  then return 1; fi # Invalid number of parameters provided",
    "    if [[ -z \\$file || ! -f \\$file  ]]; then return 2; fi # Path to a existing file must be provided",
    "    if [[ -z \\$section ]];             then return 3; fi # Section name is missing",
    "    if [[ -z \\$key ]];                 then return 4; fi # Variable name is missing",
    "    sed -nr \"/^\\\\[\\$section\\\\]/ { :l /^\\$key[ ]*=/ { s/[^=]*=[ ]*//; p; q;}; n; b l;}\" \\$file",
    "}\n"
],
  "description": "Get a value of a key(variable) under specified section in a configuration file"
},
"Save a value to a ini file": {
  "prefix": ["ini file set value", "ini file write value", "iniSetSectionKeyValue", "setIniSectionKeyValue" ],
  "body": [
      "# Function: setSectionKeyValue()",
      "# ",
      "# Brief: Adds or changes a section key value pair in a file.",
      "# ",
      "# Arguments:",
      "#     1 (\\$1):  Fully qualified path to a existing file.",
      "#     2 (\\$2):  Section name to add the key value pair to (do not include '[' and ']').",
      "#     3 (\\$3):  Name of the key to add.",
      "#     4 (\\$4):  Value to set or add.",
      "#     ",
      "# Return values:",
      "#     0 (success): If key value pair was added or it's value changed.",
      "#     1 ( error ): If file was not found.",
      "#     2 ( error ): Section name missing or invalid.",
      "#     3 ( error ): Key name missing or invalid.",
      "#     4 ( error ): Value missing or invalid.",
      "#",
      "# You can use the \\$? operator to access the function returned value.",
      "# Example: ",
      "#     if setSectionKeyValue \"settings.ini\" \"section2\" \"keyName\" \"This is a new value added\"; then",
      "#         echo \"Value added\"",
      "#     else",
      "#         echo \"Error adding a value!\"",
      "#     fi",
      "# ",
      "setSectionKeyValue() {",
      "    declare file=\\$1",
      "    declare section=\\$2",
      "    declare key=\\$3",
      "    declare value=\\$4",
      "    if ! test -f \"\\$file\";then echo \"\\${FUNCNAME[0]} error: File \\\\\"\\$file\\\\\" was not found, so unable to change key value pair.\"; return 1; fi;",
      "    if [ -z \"\\$section\" ];   then echo \"\\${FUNCNAME[0]} error: Section name missing\"; return 2; fi;",
      "    if [ -z \"\\$key\" ];   then echo \"\\${FUNCNAME[0]} error: Key name missing\";     return 3; fi;",
      "    if [ -z \"\\$4\" ];   then echo \"\\${FUNCNAME[0]} error: Value name missing\";   return 4; fi;",
      "    ",
      "    if [[ \"\\$section\" =~ .*\"[\".* || \"\\$section\" =~ .*\"]\".* ]]; then echo \"\\${FUNCNAME[0]} error: Section name invalid\"; return 2; fi;",
      "    section_start=\\$(grep -n -m 1 \"\\\\[\\$section\\\\]\" \\$file |cut -f1 -d: )",
      "    if [ -z \"\\$section_start\" ];   then ",
      "        #Section does not exist so we will append and return",
      "        echo -e \"\\\\n[\\$section]\">>\"\\$file\"; echo \"\\$key=\\$value\">>\"\\$file\"; return 0;",
      "    fi;",
      "    #The section exists in file let's find out if it is the last one",
      "    section_start=\\$((\\$section_start+1))",
      "    section_end=\\$(sed -n ''\\$section_start',\\$p' \\$file | grep -n -m 1 \"\\\\[\" |cut -f1 -d: )",
      "    if [ -z \"\\$section_end\" ]; then section_end=0; fi;",
      "    section_key=\\$(sed -n ''\\$section_start',\\$p' \\$file | grep -n -m 1 \"^\\$key=\" |cut -f1 -d: )",
      "    if [ -z \"\\$section_key\" ]; then section_key=0; fi;",
      "    if [ \\$section_end -gt 0 ]; then ",
      "        #Not the last section in the file",
      "        if [[ \\$section_key -gt 0 && \\$section_key -lt \\$section_end ]]; then ",
      "            #The key exists in this section, let's replace it's value",
      "            sed -i '/^\\\\['\\$section'\\\\]\\$/,/^\\\\[/ s/^'\\$key'=.*\\$/'\\$key'='\"\\$value\"'/' \\$file",
      "            return 0;",
      "        fi;",
      "        #The key does not exists, is not in the last section, so let's add it",
      "        declare arg='/^\\\\['\\$section'\\\\]/,/^\\\\[/ { x; /^\\$/ !{ x; H }; /^\\$/ { x; h; }; d; }; x; /^\\\\['\\$section'\\\\]/ { s/\\\\(\\\\n\\\\+[^\\\\n]*\\\\)\\$/\\\\n'\\$key'='\\$value'\\\\1/; p; x; p; x; d }; x'",
      "        sed -i \"\\$arg\" \\$file",
      "        return 0;",
      "    fi;",
      "    #Last section in the file",
      "    if [ \\$section_key -gt 0 ]; then ",
      "        #this will replace if key exists",
      "        declare arg='/^\\\\['\\$section'\\\\]\\$/,/^\\\\[/ s/^'\\$key'=.*\\$/'\\$key'='\\$value'/'",
      "        sed  -i \"\\$arg\" \\$file;",
      "    else",
      "        #The key does not exist, let's append it and it's value",
      "        echo \"\\$key=\\$value\">>\"\\$file\"",
      "    fi",
      "    return 0;",
      " }\n"
  ],
  "description": "Add or change a section key value pair in a file"
}
  }
  