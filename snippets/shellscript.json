{
    "Start of bash": {
        "prefix": ["bash", "shebang", "start"],
        "body": ["#!/usr/bin/env bash", ""],
        "description": "Start of bash\nThat is shell scripts should start with this command"
    },
    "File creation time": {
        "prefix": ["created","file created"],
        "body": ["# ${TM_FILENAME} Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}", ""],
        "description": "Add comment with file name and, file creation time"
    },
    "source sh": {
        "prefix": "source sh",
        "body": ["source \"\\$(cd \"\\$(dirname \"\\${BASH_SOURCE[0]}\")\" && pwd)/${1:filename}.sh\"\n"],
        "description": "Import another another shell script"
    },
    "declare array": {
        "prefix": "declare array",
        "body": ["declare -a ${1:name}=(${2:\"value1\" \"value2\"});\n"],
        "description": "Declare a new array and add initialize it."
    },
    "Text Color commands": {
        "prefix": "text colors",
        "body": [
            "#Text Color commands",
            "#",
            "#Brief: Commands to change the color of a text",
            "highlight=\\$(echo -en '\\033[01;37m')",
            "purpleColor=\\$(echo -en '\\033[01;35m')",
            "cyanColor=\\$(echo -en '\\033[01;36m')",
            "errorColor=\\$(echo -en '\\033[01;31m')",
            "warningColor=\\$(echo -en '\\033[00;33m')",
            "successColor=\\$(echo -en '\\033[01;32m')",
            "norm=\\$(echo -en '\\033[0m')",
            "",
            "echo \"Example color variations: \\${highlight}highlight\\${norm} text, \\${errorColor}error\\${norm} text, \\${successColor}success\\${norm} text, \\${purpleColor}purple\\${norm} text or \\${cyanColor}cyan\\${norm} text.\"",
            ""
        ],
        "description": "Text Color commands"
    },
    "Show all terminal text colors": {
        "prefix": ["terminal colors", "text colors table"],
        "body": [
            "#Terminal Text Colors",
            "#",
            "formatA=\\$(echo -en '\\\\033[100;37m')",
            "formatC=\\$(echo -en '\\\\033[5;31m')",
            "formatB=\\$(echo -en '\\\\033[01;32m')",
            "formatS=\\$(echo -en '\\\\033[103;31m')",
            "norm=\\$(echo -en '\\\\033[0m')",
            "echo \"                ────────────────────────────────\"",
            "echo \"              /\\${formatS}                                  \\${norm}\\\\\\\\\"",
            "echo \"             /\\${formatS}   \\${norm}                              \\${formatS}   \\${norm}\\\\\\\\\"",
            "echo \"            |\\${formatS}   \\${norm}      \\${formatA}Terminal\\${norm} \\${formatB}color\\${norm} \\${formatC}codes\\${norm}      \\${formatS}   \\${norm}|\"",
            "echo \"             \\\\\\\\\\${formatS}   \\${norm}                              \\${formatS}   \\${norm}/\"",
            "echo \"              \\\\\\\\\\${formatS}                                  \\${norm}/\"",
            "echo \"                ────────────────────────────────\"",
            "echo",
            "",
            "declare color SPACES",
            "for ((BACKGROUND = 0; BACKGROUND < 108; BACKGROUND++)); do",
            "    if ((BACKGROUND == 9)); then BACKGROUND=40; fi",
            "    if ((BACKGROUND == 48)); then BACKGROUND=100; fi",
            "    for ((TEXT = 30; TEXT < 98; TEXT++)); do",
            "        if ((TEXT == 38)); then TEXT=90; fi",
            "        color=\\$(echo -en \"\\\\033[\\${BACKGROUND};\\${TEXT}m\")",
            "        SPACES=\" \"",
            "        ((BACKGROUND < 10)) && SPACES=\"\\$SPACES \"",
            "        ((BACKGROUND < 100)) && SPACES=\"\\$SPACES \"",
            "",
            "        echo -ne \"\\${color}\"",
            "        echo -n \"\\\\033[\\${BACKGROUND};\\${TEXT}m\\${norm}\\$SPACES\"",
            "    done",
            "    echo",
            "done"
        ],
        "description": "Show all terminal text colors and a example on how to use colors with echo"
    },
    "Function": {
        "prefix": "function",
        "body": ["#Function: ${1:functionName}()", "#", "#Brief: ${2:What does this function solve?}", "#", "$1(){", "    $3", "}\n"],
        "description": "Create a function which takes no argument"
    },
    "Function 1 argument": {
        "prefix": "function 1 argument",
        "body": [
            "#Function: ${1:functionName}()",
            "#",
            "#Brief: ${2:What does this function solve?}",
            "#",
            "#Argument 1(\\$1): ${3:Describe argument 1}",
            "$1(){",
            "    if [ $# -ne 1 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
            "    $4",
            "}\n"
        ],
        "description": "Create a function which takes 1 argument"
    },
    "Function 2 arguments": {
        "prefix": "function 2 arguments",
        "body": [
            "#Function: ${1:functionName}()",
            "#",
            "#Brief: ${2:What does this function solve?}",
            "#",
            "#Argument 1(\\$1): ${3:Describe argument 1}",
            "#Argument 2(\\$2): ${4:Describe argument 2}",
            "$1(){",
            "    if [ $# -ne 2 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
            "    $5",
            "}\n"
        ],
        "description": "Create a function which takes 2 arguments"
    },
    "Function 3 arguments": {
        "prefix": "function 3 arguments",
        "body": [
            "#Function: ${1:functionName}()",
            "#",
            "#Brief: ${2:What does this function solve?}",
            "#",
            "#Argument 1(\\$1): ${3:Describe argument 1}",
            "#Argument 2(\\$2): ${4:Describe argument 2}",
            "#Argument 3(\\$3): ${5:Describe argument 3}",
            "$1(){",
            "    if [ $# -ne 3 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
            "    $6",
            "}\n"
        ],
        "description": "Create a function which takes 3 arguments"
    },
    "Script help function": {
        "prefix": "print help",
        "body": [
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
            "    echo \"  ${1:What does you script do?}\"",
            "    echo ",
            "    echo \"OPTIONS         Option description\"",
            "    echo \"  --help        Prints this help page\"",
            "    echo",
            "    exit 0",
            "}\n"
        ],
        "description": "Script help function"
    },
    "Help function with one option": {
        "prefix": "print help, one option",
        "body": [
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
            "    echo \"  ${1:What does you script do?}\"",
            "    echo ",
            "    echo \"OPTIONS         Option description\"",
            "    echo \"  --help        Prints this help page\"",
            "    echo \"  -${2:option}  ${4:What does $2 represent?} \"",
            "    echo",
            "    exit 0",
            "}\n"
        ],
        "description": "Help function with one option"
    },
    "Help function with one option and one option argument": {
        "prefix": "print help, one option, one option argument",
        "body": [
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
            "    printf 'Usage: %s [OPTIONS]... (-${1:source} <${2:dir}>)\\n' \"\\$(basename \"\\$0\")\"",
            "    echo \"  ${3:What does you script do?}\"",
            "    echo ",
            "    echo \"OPTIONS         Option description\"",
            "    echo \"  --help        Prints this help page\"",
            "    echo \"  -$1       ${4:What does $1 represent?} \"",
            "    echo \"  -${5:express}     ${6:What does this option represent?} \"",
            "    echo",
            "    echo \"ARGUMENTS     Option argument description\"",
            "    echo \" $2     ${7:Describe $2 in more detail!}\"",
            "    echo",
            "    exit 0",
            "}\n"
        ],
        "description": "Help function with one option and one option argument"
    },
    "Boilerplate simple": {
        "prefix": "boilerplate 1",
        "body": [
            "#!/bin/bash\n",
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
            "    echo \"  ${1:What does this script do?}\"",
            "    echo ",
            "    echo \"OPTIONS        Option description\"",
            "    echo \"  -help        Prints this help page\"",
            "    echo",
            "    exit 0",
            "}",
            "",
            "#Text Color commands",
            "#Brief: Commands to change the color of a text",
            "highlight=\\$(echo -en '\\033[01;37m')",
            "purpleColor=\\$(echo -en '\\033[01;35m')",
            "cyanColor=\\$(echo -en '\\033[01;36m')",
            "errorColor=\\$(echo -en '\\033[01;31m')",
            "warningColor=\\$(echo -en '\\033[00;33m')",
            "successColor=\\$(echo -en '\\033[01;32m')",
            "norm=\\$(echo -en '\\033[0m')",
            "",
            "#Function: parseOptions()",
            "#",
            "#Brief: Checks if all options are correct and saves them to variables",
            "#",
            "#Arguments all bash options",
            "parseOptions() {",
            "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
            "",
            "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
            "            printHelp",
            "        fi",
            "        shift",
            "    done",
            "",
            "}",
            "",
            "parseOptions \"\\$@\"",
            "",
            "echo \"Hello \\${cyanColor}bash\\${norm} world\"",
            ""
        ],
        "description": "Boilerplate simple Hello bash world"
    },
    "Boilerplate, simple one option": {
        "prefix": "boilerplate 2",
        "body": [
            "#!/bin/bash\n",
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
            "    echo \"  ${1:Description}\"",
            "    echo ",
            "    echo \"OPTIONS        Option description\"",
            "    echo \"  -help        Prints this help page\"",
            "    echo \"  -${2:express}     \"",
            "    echo",
            "    exit 0",
            "}",
            "",
            "#Text Color commands",
            "#Brief: Commands to change the color of a text",
            "highlight=\\$(echo -en '\\033[01;37m')",
            "purpleColor=\\$(echo -en '\\033[01;35m')",
            "cyanColor=\\$(echo -en '\\033[01;36m')",
            "errorColor=\\$(echo -en '\\033[01;31m')",
            "warningColor=\\$(echo -en '\\033[00;33m')",
            "successColor=\\$(echo -en '\\033[01;32m')",
            "norm=\\$(echo -en '\\033[0m')",
            "",
            "#Function: parseOptions()",
            "#",
            "#Brief: Checks if all options are correct and saves them to variables",
            "#",
            "#Arguments all bash options",
            "parseOptions() {",
            "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
            "",
            "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
            "            printHelp",
            "        elif [[ \"\\$1\" = \"-$2\" ]]; then ${2/(.*)/${1:/upcase}/}=\"true\"",
            "        else",
            "            echo \"Invalid option:  \\${errorColor}\\$1\\${norm}, get help by running command: \\$0 --help\"",
            "            exit 1",
            "        fi",
            "        ",
            "        shift",
            "    done",
            "",
            "}",
            "",
            "${2/(.*)/${1:/upcase}/}=\"false\"",
            "parseOptions \"\\$@\"",
            "",
            "echo \"Hello world ${2/(.*)/${1:/upcase}/}=\\${highlight}\\$${2/(.*)/${1:/upcase}/}\\${norm}\"",
            ""
        ],
        "description": "Boilerplate bash script with help that accepts one optional parameter"
    },
    "Boilerplate, one option, one option argument": {
        "prefix": "boilerplate 3",
        "body": [
            "#!/bin/bash",
            "",
            "#true or false options.",
            "options=( \"-h\" \"--help\" \"-${1:express}\" \"-${2:source}=\" ) ",
            "",
            "#Options that must be provided by the user",
            "optionsRequired=( ${3:\"-$1\"  \"-$2=\"} ) ",
            "",
            "#Set to true you want to allow any arguments to be given",
            "#Set to false if you only want to allow options in  \"options\" and \"optionsWithArgument\"",
            "ALLOW_UNPROCESSED=\"${4|true,false|}\" ",
            "",
            "printHelp() {",
            "    printf 'Usage: %s [OPTIONS]...\\\\n' \"\\$(basename \"\\$0\")\"",
            "    printf 'Usage: %s [OPTIONS]... (-$2=<$8>)\\\\n' \"\\$(basename \"\\$0\")\"",
            "    echo \"  ${5:What does you script do?}\"",
            "    echo ",
            "    echo \"OPTIONS         Option description\"",
            "    echo \"  --help        Prints this help page\"",
            "    echo \"  -$1    ${6:What does $1 represent?} \"",
            "    echo \"  -$2    ${7:What does $2 represent?} \"",
            "    echo",
            "    echo \"ARGUMENTS     Option argument description\"",
            "    echo \" ${8:$2Value}     ${9:Describe $8 in more detail!}\"",
            "    echo",
            "    exit 0",
            "}",
            "",
            "",
            "highlight=\\$(echo -en '\\\\033[01;37m')",
            "errorColor=\\$(echo -en '\\\\033[01;31m')",
            "warningColor=\\$(echo -en '\\\\033[00;33m')",
            "norm=\\$(echo -en '\\\\033[0m')",
            "",
            "#Function: parseOptions()",
            "#",
            "#Brief: Checks if all options are correct and saves each in a variable.",
            "#After: Value of each options given, is stored in a uppercase named variable.",
            "#       f. example -express will be stored in a global variable called EXPRESS",
            "#Returns:",
            "#      0 : (success) All parameters are valid",
            "#      1 : (error) One or more parameters are invalid",
            "#",
            "declare -a UNPROCESSED",
            "parseOptions() {",
            "    containsElement() { #if function arrayContains exists, it can be used instead of containsElement",
            "        local e match=\"\\$1\"",
            "        shift",
            "        for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
            "        return 1",
            "    }",
            "",
            "    extractArgumentValue() {",
            "        if [ \\$# -ne 2 ]; then return; fi",
            "        declare CHECK=\\$2",
            "        declare PREFIX_LEN=\\${#CHECK}",
            "        PREFIX_LEN=\\$((PREFIX_LEN + 1)) #Incrementing for equal sign",
            "        if [[ \"\\$1\" != \"\\$CHECK\"* ]]; then return; fi",
            "        echo \"\\${1:\\${PREFIX_LEN}}\"",
            "    }",
            "",
            "    extractArgumentName() {",
            "        if [ \\$# -ne 1 ]; then return; fi",
            "        if [[ \\$1 != *\"=\"* ]]; then return; fi;",
            "        declare match=\"=\"",
            "        declare prefix=\\${1%%\"\\$match\"*}",
            "        echo \"\\${prefix}\"",
            "    }",
            "",
            "    declare -a _optionsFound",
            "    declare tmp tmpValue tmpName",
            "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
            "        tmp=\"$1\"",
            "        tmpValue=\"true\"",
            "        tmpName=\\$(extractArgumentName \"\\$1\")",
            "",
            "        if [[ -n \"\\$tmpName\" ]] && containsElement \"\\$tmpName=\" \"\\${options[@]}\"; then",
            "            tmpValue=\\$(extractArgumentValue \"\\$1\" \"\\$tmpName\")",
            "            tmp=\\$tmpName",
            "            tmpName=\"\\$tmpName=\"",
            "            _optionsFound+=(\"\\$tmpName\")",
            "        elif containsElement \"\\$1\" \"\\${options[@]}\"; then",
            "            tmp=\"\\$1\"",
            "            tmpName=\"\\$tmp\"",
            "            _optionsFound+=(\"\\$tmpName\")",
            "        elif [[ \"\\$ALLOW_UNPROCESSED\" == \"true\" ]]; then",
            "            UNPROCESSED+=(\"\\$1\")",
            "            _optionsFound+=(\"\\$1\")",
            "        else",
            "            echo \"\\${errorColor}Error: \\${highlight}\\$1\\${norm} is an invalid argument.\"",
            "            return 1",
            "        fi",
            "        #removing prefix - and -- and assigning value to upper cased variable.",
            "",
            "        tmp=\\${tmp#\"-\"}                  # removing -",
            "        tmp=\\${tmp#\"-\"}                  # removing - if there were two",
            "        tmp=\\$(echo \"\\$tmp\" | tr a-z A-Z) # CAPITALIZING the variable name",
            "        printf -v \"\\$tmp\" \"\\$tmpValue\"    # Assigning a value to VARIABLE",
            "        if [[ -z \"\\$tmpValue\" ]]; then",
            "            echo \"Value missing for \\$tmpName\"",
            "            return 1",
            "        fi",
            "",
            "        shift",
            "    done",
            "    if [[ -n \"\\$HELP\" || -n \"\\$H\" ]]; then printHelp; fi",
            "    #Check if all required options have been provided.",
            "    if [[ \\${#optionsRequired[@]} -eq 0 ]]; then return 0; fi",
            "    for arg in \"\\${optionsRequired[@]}\"; do",
            "        if ! containsElement \"\\$arg\" \"\\${_optionsFound[@]}\"; then",
            "            echo \"\\${errorColor}Required option missing \\${norm} \\$arg \"",
            "            return 1",
            "        fi",
            "    done",
            "}",
            "",
            "# You could test code below by running this script with these Arguments",
            "#   ./thisScript.sh -$1 -$2=\"~/Downloads /home/gandalf\" -weird",
            "if ! parseOptions \"\\$@\"; then exit 1; fi",
            "if [[ -n \"\\$${1/(.*)/${1:/upcase}/}\" ]]; then echo \"-$1=\\\"\\$${1/(.*)/${1:/upcase}/}\\\"\"; fi",
            "if [[ -n \"\\$${2/(.*)/${1:/upcase}/}\" ]]; then echo \"-$2=\\\"\\$${2/(.*)/${1:/upcase}/}\\\"\"; fi",
            "",
            "for arg in \"\\${UNPROCESSED[@]}\"; do",
            "    echo  \"\\${warningColor}Unprocessed argument\\${norm} \\$arg \"",
            "done",
            "",
            ""
        ],
        "description": "Boilerplate with one option and one option which requires a argument"
    },
    "Check if all options are valid and saves each in a variable": {
        "prefix": "parse options",
        "body": [
            "",
            "#true or false options.",
            "options=( \"-h\" \"--help\" \"-${1:express}\" \"-${2:source}=\" ) ",
            "",
            "#Options that must be provided by the user",
            "optionsRequired=( ${3:\"-$1\"  \"-$2=\"} ) ",
            "",
            "#Set to true you want to allow any arguments to be given",
            "#Set to false if you only want to allow options in  \"options\" and \"optionsWithArgument\"",
            "ALLOW_UNPROCESSED=\"${4|true,false|}\" ",
            "",
            "printHelp() {",
            "    echo \"  TODO: Write help for this script\"",
            "    exit 0",
            "}",
            "",
            "",
            "highlight=\\$(echo -en '\\\\033[01;37m')",
            "errorColor=\\$(echo -en '\\\\033[01;31m')",
            "warningColor=\\$(echo -en '\\\\033[00;33m')",
            "norm=\\$(echo -en '\\\\033[0m')",
            "",
            "#Function: parseOptions()",
            "#",
            "#Brief: Checks if all options are correct and saves each in a variable.",
            "#After: Value of each options given, is stored in a uppercase named variable.",
            "#       f. example -express will be stored in a global variable called EXPRESS",
            "#Returns:",
            "#      0 : (success) All parameters are valid",
            "#      1 : (error) One or more parameters are invalid",
            "#",
            "declare -a UNPROCESSED",
            "parseOptions() {",
            "    containsElement() { #if function arrayContains exists, it can be used instead of containsElement",
            "        local e match=\"\\$1\"",
            "        shift",
            "        for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
            "        return 1",
            "    }",
            "",
            "    extractArgumentValue() {",
            "        if [ \\$# -ne 2 ]; then return; fi",
            "        declare CHECK=\\$2",
            "        declare PREFIX_LEN=\\${#CHECK}",
            "        PREFIX_LEN=\\$((PREFIX_LEN + 1)) #Incrementing for equal sign",
            "        if [[ \"\\$1\" != \"\\$CHECK\"* ]]; then return; fi",
            "        echo \"\\${1:\\${PREFIX_LEN}}\"",
            "    }",
            "",
            "    extractArgumentName() {",
            "        if [ \\$# -ne 1 ]; then return; fi",
            "        if [[ \\$1 != *\"=\"* ]]; then return; fi;",
            "        declare match=\"=\"",
            "        declare prefix=\\${1%%\"\\$match\"*}",
            "        echo \"\\${prefix}\"",
            "    }",
            "",
            "    declare -a _optionsFound",
            "    declare tmp tmpValue tmpName",
            "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
            "        tmp=\"$1\"",
            "        tmpValue=\"true\"",
            "        tmpName=\\$(extractArgumentName \"\\$1\")",
            "",
            "        if [[ -n \"\\$tmpName\" ]] && containsElement \"\\$tmpName=\" \"\\${options[@]}\"; then",
            "            tmpValue=\\$(extractArgumentValue \"\\$1\" \"\\$tmpName\")",
            "            tmp=\\$tmpName",
            "            tmpName=\"\\$tmpName=\"",
            "            _optionsFound+=(\"\\$tmpName\")",
            "        elif containsElement \"\\$1\" \"\\${options[@]}\"; then",
            "            tmp=\"\\$1\"",
            "            tmpName=\"\\$tmp\"",
            "            _optionsFound+=(\"\\$tmpName\")",
            "        elif [[ \"\\$ALLOW_UNPROCESSED\" == \"true\" ]]; then",
            "            UNPROCESSED+=(\"\\$1\")",
            "            _optionsFound+=(\"\\$1\")",
            "        else",
            "            echo \"\\${errorColor}Error: \\${highlight}\\$1\\${norm} is an invalid argument.\"",
            "            return 1",
            "        fi",
            "        #removing prefix - and -- and assigning value to upper cased variable.",
            "",
            "        tmp=\\${tmp#\"-\"}                  # removing -",
            "        tmp=\\${tmp#\"-\"}                  # removing - if there were two",
            "        tmp=\\$(echo \"\\$tmp\" | tr a-z A-Z) # CAPITALIZING the variable name",
            "        printf -v \"\\$tmp\" \"\\$tmpValue\"    # Assigning a value to VARIABLE",
            "        if [[ -z \"\\$tmpValue\" ]]; then",
            "            echo \"Value missing for \\$tmpName\"",
            "            return 1",
            "        fi",
            "",
            "        shift",
            "    done",
            "    if [[ -n \"\\$HELP\" || -n \"\\$H\" ]]; then printHelp; fi",
            "    #Check if all required options have been provided.",
            "    if [[ \\${#optionsRequired[@]} -eq 0 ]]; then return 0; fi",
            "    for arg in \"\\${optionsRequired[@]}\"; do",
            "        if ! containsElement \"\\$arg\" \"\\${_optionsFound[@]}\"; then",
            "            echo \"\\${errorColor}Required option missing \\${norm} \\$arg \"",
            "            return 1",
            "        fi",
            "    done",
            "}",
            "",
            "# You could test code below by running this script with these Arguments",
            "#   ./thisScript.sh -$1 -$2=\"~/Downloads /home/gandalf\" -weird",
            "if ! parseOptions \"\\$@\"; then exit 1; fi",
            "if [[ -n \"\\$${1/(.*)/${1:/upcase}/}\" ]]; then echo \"-$1=\\\"\\$${1/(.*)/${1:/upcase}/}\\\"\"; fi",
            "if [[ -n \"\\$${2/(.*)/${1:/upcase}/}\" ]]; then echo \"-$2=\\\"\\$${2/(.*)/${1:/upcase}/}\\\"\"; fi",
            "",
            "for arg in \"\\${UNPROCESSED[@]}\"; do",
            "    echo  \"\\${warningColor}Unprocessed argument\\${norm} \\$arg \"",
            "done",
            "",
            ""
        ],
        "description": "Check if all options are valid and saves each in a variable"
    },
    "Only allow super user to run this script": {
        "prefix": ["is super", "is root", "is sudo"],
        "body": [
            "if ((\\$EUID != 0)); then",
            "    echo \"Error: This command has to be run with superuser privileges (under the root user on most systems).\"",
            "    exit 1",
            "fi"
        ],
        "description": "Only allow super user to run this script."
    },

    "Frame your text": {
        "prefix": "frame",
        "body": [
            "#Function: frame()",
            "#",
            "#Brief: Writes pretty frame around provide text to the terminal",
            "#",
            "# Usage frame [OPTION]... <text>",
            "# OPTIONS",
            "#  --     The frame will drawn with a single line",
            "#  -=     The frame will drawn with a double line",
            "#  -c     The frame will be drawn with provided character.  This option must be ",
            "#         followed be the character to be used for drawing the frame surrounding",
            "#         frame. b Sometimes you will need to double quote this character, ",
            "#         For example for * you will need to double quote like this \"*\".",
            "#  -t     Only top part of the frame will be printed <text> will be ignored",
            "#  -b     Only the bottom part of the frame will be printed <text> will be ignored",
            "#  -m     Only provided text will be printed with surrounding frame sides",
            "#  -l     Provided <text> should be left aligned",
            "#  -r     Provided <text> should be right aligned",
            "#  -f     If provided the next parameter must contain the",
            "#         formatting to be used on the text inside the frame.",
            "#  -line  Print a horizontal line, <text> will be ignored",
            "#  -dLine Print a horizontal dashed line, <text> will be ignored",
            "#  -w     If provided the next parameter must contain a number representing how",
            "#         wide you want the surrounding frame to be, by default this number is 80.",
            "#",
            "#Please remember to double quote all parameters",
            "#example on how to write a blue text with double quoted frame around it:",
            "#  frame  -c = -f \\$(echo -en '\\033[01;34m') \"I am blue text\"",
            "#example on how to align many lines within one frame",
            "#  frame -w 50 -t",
            "#  frame -w 50 -m \"I am left aligned with no space\" -l",
            "#  frame -w 50 -m \"I am centered text\"",
            "#  frame -w 50 -m \" I am right aligned with 5 spaces     \" -r",
            "#  frame -w 50 -b",
            "frame() {",
            "    declare align='center'; #Alignment for text inside the frame",
            "    declare format;         #Text formatting",
            "    declare parts=\"all\";    #Print frame part- top, lower, middle or all parts.",
            "    declare box=\"-\";        #character(s) surrounding the text which will make the frame.",
            "    declare width=\"80\";     #The frame width",
            "    declare text;",
            "    declare normal=\\$(echo -en '\\033[0m')",
            "",
            "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
            "        ",
            "        if [[ \"\\$1\" = \"--\" ]]; then",
            "           box=\"-\"",
            "        elif [[ \"\\$1\" = \"-=\" ]]; then",
            "           box=\"=\"",
            "        elif [[ \"\\$1\" = \"-t\" ]]; then",
            "            parts=\"top\";",
            "        elif [[ \"\\$1\" = \"-m\" ]]; then",
            "            parts=\"middle\";",
            "        elif [[ \"\\$1\" = \"-b\" ]]; then",
            "            parts=\"bottom\";",
            "        elif [[ \"\\$1\" = \"-l\" ]]; then",
            "            align=\"left\";",
            "        elif [[ \"\\$1\" = \"-line\" ]]; then",
            "            echo -n \"├\"; printf '─%.0s' \\$(seq \\$((\\$width - 2)) ); echo \"┤\"; return",
            "        elif [[ \"\\$1\" = \"-dLine\" ]]; then",
            "            echo -n \"│\"; printf -- '-%.0s' \\$(seq \\$((\\$width - 2)) ); echo \"│\"; return",
            "        elif [[ \"\\$1\" = \"-r\" ]]; then",
            "            align=\"right\";",
            "        elif [[ \"\\$1\" = \"-c\" ]]; then",
            "           #We will need string of length 1 next",
            "           shift;",
            "            if [[ -z \\$1 || -n \\$1 && \\${#1} -ne 1 ]]; then echo \"Option -c will need to be followed by a character\" ; exit 1; fi;",
            "            box=\"\\$1\"",
            "        elif [[ \"\\$1\" = \"-w\" ]]; then",
            "           #We will need string of length 1 next",
            "           shift;",
            "           re='^[0-9]+\\$'",
            "            if ! [[  \"\\$1\" =~ \\$re ]] ; then echo \"Option -w will need to be followed by a number\" ; exit 1; fi;",
            "            width=\"\\$1\"",
            "        elif [[ \"\\$1\" = \"-f\" ]]; then",
            "           shift;",
            "           #We will need the formatting string next",
            "            if [ -z \\$1 ]; then echo \"Formatting option provided but formatting value missing!\" ; exit 1; fi;",
            "            format=\"\\$1\"",
            "        else",
            "            text=\"\\$1\"",
            "        fi",
            "        shift",
            "    done",
            "    if [[ -z \"\\$text\" &&  ( \"\\$parts\" != \"top\" && \"\\$parts\" != \"bottom\"  ) ]]; then echo \"Error No text Provided\"; exit 1; fi;",
            "        declare char=\"\\$box\"",
            "        declare side=\"\\$box\"",
            "        declare upLeft=\"\\$box\"",
            "        declare upRight=\"\\$box\"",
            "        declare downLeft=\"\\$box\"",
            "        declare downRight=\"\\$box\"",
            "    if [[ \"\\$box\" = \"=\" ]]; then",
            "        char=\"═\"",
            "        side=\"║\"",
            "        upLeft=\"╔\"",
            "        upRight=\"╗\"",
            "        downLeft=\"╚\"",
            "        downRight=\"╝\"",
            "    elif [[ \"\\$box\" = \"-\" ]]; then",
            "        char=\"─\"",
            "        side=\"│\"",
            "        upLeft=\"┌\"",
            "        upRight=\"┐\"",
            "        downLeft=\"└\"",
            "        downRight=\"┘\"",
            "    fi",
            "    STRING=\\$text",
            "    size=\\$(((\\$((width - 2)) - (\\${#STRING})) / 2))",
            "    str=\"%0.s\\$char\"",
            "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"top\" ]]; then",
            "        echo -en \"\\$upLeft\"",
            "        printf \\$str \\$(seq 1 \\$((width - 2)))",
            "        printf \"\\$upRight\\n\"",
            "    fi",
            "    pad=\\$(printf '%*s' \"\\$size\")",
            "    ",
            "    if [ \\$((\\${#STRING} % 2)) -eq 0 ]; then pad2=\"\\${pad}\"; else pad2=\"\\${pad} \"; fi",
            "    ",
            "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"middle\" ]]; then",
            "        if [[ \"\\$align\" = \"left\" ]]; then",
            "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
            "            pad=\\$(printf '%*s' \"\\$size\")",
            "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
            "            echo -e \"\\$side\\$STRING\\$pad\\$side\"",
            "        elif [[ \"\\$align\" = \"right\" ]]; then",
            "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
            "            pad=\\$(printf '%*s' \"\\$size\")",
            "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
            "            echo -e \"\\$side\\$pad\\$STRING\\$side\"",
            "        else",
            "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
            "            echo -e \"\\$side\\$pad\\$STRING\\$pad2\\$side\"",
            "        fi",
            "    fi",
            "    #normal",
            "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"bottom\" ]]; then",
            "        printf \"\\$downLeft\"",
            "        printf \\$str \\$(seq 1 \\$((width - 2)))",
            "        printf \"\\$downRight\\n\"",
            "    fi",
            "}",
            "",
            "frame \"I am a looking good title\""
        ],
        "description": "Frame your text"
    },
    "Select pre defined option": {
        "prefix": "menuOptions",
        "body": [
            "# Renders a text based list of options that can be selected by the",
            "# user using up, down and enter keys and returns the chosen option.",
            "#",
            "#   Arguments   : list of options, maximum of 256",
            "#                 \"opt1\" \"opt2\" ...",
            "#   Return value: selected index (0 for opt1, 1 for opt2 ...)",
            "function menuOption {",
            "",
            "    # little helpers for terminal print control and key input",
            "    ESC=\\$( printf \"\\033\")",
            "    cursor_blink_on()  { printf \"\\$ESC[?25h\"; }",
            "    cursor_blink_off() { printf \"\\$ESC[?25l\"; }",
            "    cursor_to()        { printf \"\\$ESC[\\$1;\\${2:-1}H\"; }",
            "    print_option()     { printf \"   \\$1 \"; }",
            "    print_selected()   { printf \"  \\$ESC[7m \\$1 \\$ESC[27m\"; }",
            "    get_cursor_row()   { IFS=';' read -sdR -p \\$'\\E[6n' ROW COL; echo \\${ROW#*[}; }",
            "    key_input()        { read -s -n3 key 2>/dev/null >&2",
            "                         if [[ \\$key = \\$ESC[A ]]; then echo up;    fi",
            "                         if [[ \\$key = \\$ESC[B ]]; then echo down;  fi",
            "                         if [[ \\$key = \"\"     ]]; then echo enter; fi; }",
            "",
            "    # initially print empty new lines (scroll down if at bottom of screen)",
            "    for opt; do printf \"\\n\"; done",
            "",
            "    # determine current screen position for overwriting the options",
            "    local lastrow=`get_cursor_row`",
            "    local startrow=\\$((\\$lastrow - \\$#))",
            "",
            "    # ensure cursor and input echoing back on upon a ctrl+c during read -s",
            "    trap \"cursor_blink_on; stty echo; printf '\\n'; exit\" 2",
            "    cursor_blink_off",
            "",
            "    local selected=0",
            "    while true; do",
            "        # print options by overwriting the last lines",
            "        local idx=0",
            "        for opt; do",
            "            cursor_to \\$((\\$startrow + \\$idx))",
            "            if [ \\$idx -eq \\$selected ]; then",
            "                print_selected \"\\$opt\"",
            "            else",
            "                print_option \"\\$opt\"",
            "            fi",
            "            ((idx++))",
            "        done",
            "",
            "        # user key control",
            "        case `key_input` in",
            "            enter) break;;",
            "            up)    ((selected--));",
            "                   if [ \\$selected -lt 0 ]; then selected=\\$((\\$# - 1)); fi;;",
            "            down)  ((selected++));",
            "                   if [ \\$selected -ge \\$# ]; then selected=0; fi;;",
            "        esac",
            "    done",
            "",
            "    # cursor position back to normal",
            "    cursor_to \\$lastrow",
            "    #printf \"\\n\"",
            "    cursor_blink_on",
            "",
            "    return \\$selected",
            "}",
            "",
            "#How to use this menu",
            "",
            "while true; do",
            "    options=(\"first option\" \"second option\" \"third option\" \"exit\")",
            "    menuOption \"\\${options[@]}\"",
            "    choice=\\$?",
            "    case \\$choice in",
            "    0)",
            "        echo \"First option was selected\";;",
            "    1) ",
            "        echo \"Second option was selected\";;",
            "    2)",
            "        echo \"Third option was selected\";;",
            "    3) ",
            "        echo \"exit selected\"",
            "        exit 0;;",
            "    esac",
            "",
            "    echo \"Chosen index = \\\"\\$choice\\\" value=\\\"\\${options[\\$choice]}\\\"\"",
            "    sleep 2.5",
            "done\n"
        ],
        "description": "Select pre defined option"
    },
    "Searches for an string within an array of strings": {
        "prefix": "arrayContains",
        "body": [
            "#Function: arrayContains()",
            "#",
            "#Brief: Searches for an string within an array of strings",
            "#",
            "#Argument 1(\\$1): String to search for",
            "#Argument 2(\\$2): Array of strings",
            "#Returns",
            "#       0 if found",
            "#       1 if not found",
            "#Example:",
            "#  flags=(\"-reset\" \"-express\" \"-source\")",
            "#   if arrayContains \"-express\" \"\\${flags[@]}\"; then",
            "#      echo \"String was found\"",
            "#   else",
            "#       echo \"String not found!\"",
            "#   fi",
            "arrayContains() {",
            "    local e match=\"\\$1\"",
            "    shift",
            "    for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
            "    return 1",
            "}\n"
        ],
        "description": "Searches for an string within an array of strings"
    },
    "For number loop": {
        "prefix": "for number",
        "body": ["for (( i=0; i<10; i++ )); do", " echo -n \"\\$i \"", "done\n"],
        "description": "For loop with a number condition variable"
    },
    "For number in braces": {
        "prefix": "for number braces",
        "body": ["for i in {1..10}", "do", "    echo -n \"\\$i \"", "done\n"],
        "description": "For loop with brace expansion"
    },
    "Case Example": {
        "prefix": "case example",
        "body": [
            "ANIMAL=\"cat\"",
            "echo -n \"\\$ANIMAL is \"",
            "case \\$ANIMAL in ",
            "    hawk)",
            "        echo \"a bird\"",
            "        ;;",
            "    dog|cat) ",
            "        echo \"a pet\"",
            "        ;;",
            "    *)",
            "      echo \"unknown\"",
            "        ;;",
            "esac"
        ],
        "description": "Case Statement Example"
    },
    "Case": {
        "prefix": "case",
        "body": [
            "case $1 in ",
            "    ${2:hawk})",
            "        ${3:echo \"a bird\"}",
            "        ;;",
            "    ${4:dog|cat}) ",
            "        ${5:echo \"a pet\"}",
            "        ;;",
            "    *)",
            "      ${6:echo \"unknown\"}",
            "        ;;",
            "esac\n"
        ],
        "description": "Case statement"
    },
    "Extract argument name from option": {
        "prefix": "extract argument name",
        "body": [
            "    #Function: extractArgumentName()",
            "    #",
            "    #Brief: Extracts a name from a given argument which is on the form -name=value or name=\"value with spaces\"",
            "    #",
            "    #Argument 1(\\$1): Argument containing prefixed argument -name=suffixed argument value",
            "    #Returns       : On success the all in front of = including the - sign, on error nothing",
            "    extractArgumentName() {",
            "        if [ \\$# -ne 1 ]; then return; fi",
            "        if [[ \\$1 != *\"=\"* ]]; then return; fi;",
            "        declare match=\"=\"",
            "        declare prefix=\\${1%%\"\\$match\"*}",
            "        echo \"\\${prefix}\"",
            "    }"
        ],
        "description": "Extracts a name from a given argument which is on the form -name=value or name=\"value with spaces\""
    },
    "Extract argument value from option": {
        "prefix": "extract argument value",
        "body": [
            "    #Function: extractArgumentValue()",
            "    #",
            "    #Brief: Extracts a value from a given argument which is on the form name=value or name=\"value with spaces\"",
            "    #",
            "    #Argument 1(\\$1): Argument containing prefixed argument including - sign -name=suffixed argument value",
            "    #Argument 2(\\$2): Argument name  (what should be in front of the = sign)",
            "    #Returns       : On success the value, on error nothing",
            "    extractArgumentValue() {",
            "        if [ \\$# -ne 2 ]; then return; fi",
            "        declare CHECK=\\$2",
            "        declare PREFIX_LEN=\\${#CHECK}",
            "        PREFIX_LEN=\\$((PREFIX_LEN + 1)) #Incrementing for equal sign",
            "        if [[ \"\\$1\" != \"\\$CHECK\"* ]]; then return; fi",
            "        echo \"\\${1:\\${PREFIX_LEN}}\"",
            "    }"
        ],
        "description": "Extracts a value from a given argument which is on the form name=value or name=\"value with spaces\""
    },
    "Extracts filename from the last argument": {
      "prefix":[ "extract filename", "remove directory from path" , "remove prefix from path" ],
      "body": [
          "#Function: removePathFromLastArg()",
          "#",
          "#Brief: Extracts filename from the last argument and echos out all all arguments ",
          "#       where the last argument has been stripped of preceding path or url",
          "#",
          "#Argument n(\\$n): Any number of arguments, where the last argument is changed if it contains a path or a url",
          "#returns       : All arguments where last argument does not contain a path",
          "#",
          "#Example usage : removePathFromLastArg https://guttih.com/myFile.txt",
          "#                removePathFromLastArg -src=\"https://guttih.com/myFile.txt\"",
          "#",
          "#                ARGS_ARRAY=\\$(removePathFromLastArg -argument something -src=https://guttih.com/myFile.txt)",
          "#                echo \"My new args: \\${ARGS_ARRAY[*]}\"",
          "removePathFromLastArg(){",
          "",
          "    extractArgumentName() {",
          "          if [ \\$# -ne 1 ]; then return; fi",
          "          declare match=\"=\"",
          "          if [[ \\$1 != *\"=\"* ]]; then return; fi;",
          "          declare prefix=\\${1%%\"\\$match\"*}",
          "          echo \"\\${prefix}\"",
          "    }",
          "",
          "    extractArgumentValue() {",
          "        if [ \\$# -ne 2 ]; then return; fi",
          "        declare CHECK=\\$2",
          "        declare PREFIX_LEN=\\${#CHECK}",
          "        PREFIX_LEN=\\$((PREFIX_LEN + 1)) #Incrementing for equal sign",
          "        if [[ \"\\$1\" != \"\\$CHECK\"* ]]; then return; fi",
          "        echo \"\\${1:\\${PREFIX_LEN}}\"",
          "    }",
          "",
          "     if [ \\$# -lt 1 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
          "    declare args=( \"\\$@\"  )",
          "    declare URL=\\${args[-1]}",
          "",
          "    #check if argument is on the form name=\"value\"",
          "    declare tmpName=\\$(extractArgumentName \"\\$URL\")",
          "    if [[ -n \"\\$tmpName\" ]];  then ",
          "        URL=\\$(extractArgumentValue \"\\$URL\" \"\\$tmpName\")",
          "    fi",
          "    declare PACKAGE=\\$(printf '%s\\\\n' \"\\${URL##*/}\" )",
          "    unset 'args[-1]' # removes the last element",
          "    echo  \"\\${args[@]}\" \"\\$PACKAGE\"",
          "}\n"
      ],
      "description": "Extracts filename from the last argument and echos out all all arguments, where the last argument has been stripped of preceding path or url"
  },"Is script sourced": {
    "prefix": "is script sourced",
    "body": [
        " #Function: isSourced()",
        " #",
        " #Brief: Checks if the running bash script is being sourced",
        " #Example:",
        " #    if isSourced; then",
        " #        echo \"This script is being sourced\"",
        " #    else",
        " #        echo \"This script is NOT being sourced\"",
        " #    fi",
        " isSourced() {",
        "   if [ -n \"\\$ZSH_VERSION\" ]; then ",
        "       case \\$ZSH_EVAL_CONTEXT in *:file:*) return 0;; esac",
        "   else  # Add additional POSIX-compatible shell names here, if needed.",
        "       case \\${0##*/} in dash|-dash|bash|-bash|ksh|-ksh|sh|-sh) return 0;; esac",
        "   fi",
        "   return 1  # NOT sourced.",
        " }",
        ""
    ],
    "description": "Check if your script is being sourced or not.  That is, if f.example environment variables created will effect the  calling shell"
},
"Is command installed": {
    "prefix": "is command installed",
    "body": [
        "#Function: isCommandInstalled()",
        "#",
        "#Brief: Checks if a command or a package is installed, by trying to run it",
        "#",
        "#Argument 1(\\$1): command to test if it's installed",
        "#Usage example :",
        "#  if ! isCommandInstalled  ls ; then echo \"You can install it with \\\\\"sudo dnf install tree\\\\\"\"; fi",
        "isCommandInstalled(){",
        "    if [ \\$# -ne 1 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
        "    if ! command -v \"\\$1\" &> /dev/null; then ",
        "        echo \"\\$1 is not installed\"; ",
        "        return 1",
        "        fi",
        "}",
        "",
        ""
    ],
    "description": "Check if a command is installed"
}
}
