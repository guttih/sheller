{
  "Start of bash": {
    "prefix": ["bash", "shebang", "start"],
    "body": ["#!/usr/bin/env bash", ""],
    "description": "Start of bash\nThat is shell scripts should start with this command"
  },
  "File creation time": {
    "prefix": "#Created",
    "body": [
      "# ${TM_FILENAME} Created: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
      ""
    ],
    "description": "File creation time"
  },
  "source sh": {
    "prefix": "Source sh",	
    "body": ["source \"\\$(cd \"\\$(dirname \"\\${BASH_SOURCE[0]}\")\" && pwd)/${1:filename}.sh\"\n"], 
    "description": "Import another another shell script" 
  },
  "declare array":{ 
    "prefix": "declare array",	
    "body": ["declare -a ${1:name}=(${2:\"value1\" \"value2\"});\n"], 
    "description": "Declare a new array and add initialize it." },
  "Text Color commands": {
    "prefix": "text colors",
    "body": [
      "#Text Color commands",
      "#",
      "#Brief: Commands to change the color of a text",
      "highlight=\\$(echo -en '\\033[01;37m')",
      "purpleColor=\\$(echo -en '\\033[01;35m')",
      "cyanColor=\\$(echo -en '\\033[01;36m')",
      "errorColor=\\$(echo -en '\\033[01;31m')",
      "warningColor=\\$(echo -en '\\033[00;33m')",
      "successColor=\\$(echo -en '\\033[01;32m')",
      "norm=\\$(echo -en '\\033[0m')",
      "",
      "echo \"Example color variations: \\${highlight}higlight\\${norm} text, \\${errorColor}error\\${norm} text, \\${successColor}success\\${norm} text, \\${purpleColor}purple\\${norm} text or \\${cyanColor}cyan\\${norm} text.\"",
      ""
    ],
    "description": "Text Color commands"
  },
  "Show all termianl text colors": {
    "prefix": "text colors table",
    "body": [
        "#Terminal Text Colors",
        "#",
        "formatA=\\$(echo -en '\\\\033[100;37m')",
        "formatC=\\$(echo -en '\\\\033[5;31m')",
        "formatB=\\$(echo -en '\\\\033[01;32m')",
        "formatS=\\$(echo -en '\\\\033[103;31m')",
        "norm=\\$(echo -en '\\\\033[0m')",
        "echo \"                ────────────────────────────────\"",
        "echo \"              /\\${formatS}                                  \\${norm}\\\\\\\\\"",
        "echo \"             /\\${formatS}   \\${norm}                              \\${formatS}   \\${norm}\\\\\\\\\"",
        "echo \"            |\\${formatS}   \\${norm}      \\${formatA}Terminal\\${norm} \\${formatB}color\\${norm} \\${formatC}codes\\${norm}      \\${formatS}   \\${norm}|\"",
        "echo \"             \\\\\\\\\\${formatS}   \\${norm}                              \\${formatS}   \\${norm}/\"",
        "echo \"              \\\\\\\\\\${formatS}                                  \\${norm}/\"",
        "echo \"                ────────────────────────────────\"",
        "echo",
        "",
        "declare color SPACES",
        "for ((BACKGROUND = 0; BACKGROUND < 108; BACKGROUND++)); do",
        "    if ((BACKGROUND == 9)); then BACKGROUND=40; fi",
        "    if ((BACKGROUND == 48)); then BACKGROUND=100; fi",
        "    for ((TEXT = 30; TEXT < 98; TEXT++)); do",
        "        if ((TEXT == 38)); then TEXT=90; fi",
        "        color=\\$(echo -en \"\\\\033[\\${BACKGROUND};\\${TEXT}m\")",
        "        SPACES=\" \"",
        "        ((BACKGROUND < 10)) && SPACES=\"\\$SPACES \"",
        "        ((BACKGROUND < 100)) && SPACES=\"\\$SPACES \"",
        "",
        "        echo -ne \"\\${color}\"",
        "        echo -n \"\\\\033[\\${BACKGROUND};\\${TEXT}m\\${norm}\\$SPACES\"",
        "    done",
        "    echo",
        "done"
    ],
    "description": "Show all terminal text colors and a example on how to use colors with echo"
},
  "Function": {
    "prefix": "function",
    "body": [
      "#Function: ${1:functionName}()",
      "#",
      "#Brief: ${2:What does this function solve?}",
      "#",
      "$1(){",
      "    $3",
      "}\n"
    ],
    "description": "Create a function which takes no argument"
  },
  "Function 1 argument": {
    "prefix": "function 1 argument",
    "body": [
      "#Function: ${1:functionName}()",
      "#",
      "#Brief: ${2:What does this function solve?}",
      "#",
      "#Argument 1(\\$1): ${3:Describe argument 1}",
      "$1(){",
      "    if [ $# -ne 1 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
      "    $4",
      "}\n"
    ],
    "description": "Create a function which takes 1 argument"
  },
  "Function 2 arguments": {
    "prefix": "function 2 arguments",
    "body": [
      "#Function: ${1:functionName}()",
      "#",
      "#Brief: ${2:What does this function solve?}",
      "#",
      "#Argument 1(\\$1): ${3:Describe argument 1}",
      "#Argument 2(\\$2): ${4:Describe argument 2}",
      "$1(){",
      "    if [ $# -ne 2 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
      "    $5",
      "}\n"
    ],
    "description": "Create a function which takes 2 arguments"
  },
  "Function 3 arguments": {
    "prefix": "function 3 arguments",
    "body": [
      "#Function: ${1:functionName}()",
      "#",
      "#Brief: ${2:What does this function solve?}",
      "#",
      "#Argument 1(\\$1): ${3:Describe argument 1}",
      "#Argument 2(\\$2): ${4:Describe argument 2}",
      "#Argument 3(\\$3): ${5:Describe argument 3}",
      "$1(){",
      "    if [ $# -ne 3 ]; then echo \"Invalid number of parameters provided to \\$FUNCNAME\"; exit 1; fi",
      "    $6",
      "}\n"
    ],
    "description": "Create a function which takes 3 arguments"
  },
  "Script help function": {
    "prefix": "Print help",
    "body": [
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    echo \"  ${1:What does you script do?}\"",
      "    echo ",
      "    echo \"OPTIONS         Option description\"",
      "    echo \"  --help        Prints this help page\"",
      "    echo",
      "    exit 0",
      "}\n"
    ],
    "description": "Script help function"
  },
  "Help function with one option": {
    "prefix": "Print help, one option",
    "body": [
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    echo \"  ${1:What does you script do?}\"",
      "    echo ",
      "    echo \"OPTIONS         Option description\"",
      "    echo \"  --help        Prints this help page\"",
      "    echo \"  -${2:option}  ${4:What does $2 represent?} \"",
      "    echo",
      "    exit 0",
      "}\n"
    ],
    "description": "Help function with one option"
  },
  "Help function with one option and one option argument": {
    "prefix": "Print help, one option, one option argument",
    "body": [
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    printf 'Usage: %s [OPTIONS]... (-${1:source} <${2:dir}>)\\n' \"\\$(basename \"\\$0\")\"",
      "    echo \"  ${3:What does you script do?}\"",
      "    echo ",
      "    echo \"OPTIONS         Option description\"",
      "    echo \"  --help        Prints this help page\"",
      "    echo \"  -$1       ${4:What does $1 represent?} \"",
      "    echo \"  -${5:express}     ${6:What does this option represent?} \"",
      "    echo",
      "    echo \"ARGUMENTS     Option argument description\"",
      "    echo \" $2     ${7:Describe $2 in more detail!}\"",
      "    echo",
      "    exit 0",
      "}\n"
    ],
    "description": "Help function with one option and one option argument"
  },
  "Boilerplate simple": {
    "prefix": "Boilerplate 1",
    "body": [
      "#!/bin/bash\n",
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    echo \"  ${1:What does this script do?}\"",
      "    echo ",
      "    echo \"OPTIONS        Option description\"",
      "    echo \"  -help        Prints this help page\"",
      "    echo",
      "    exit 0",
      "}",
      "",
      "#Text Color commands",
      "#Brief: Commands to change the color of a text",
      "highlight=\\$(echo -en '\\033[01;37m')",
      "purpleColor=\\$(echo -en '\\033[01;35m')",
      "cyanColor=\\$(echo -en '\\033[01;36m')",
      "errorColor=\\$(echo -en '\\033[01;31m')",
      "warningColor=\\$(echo -en '\\033[00;33m')",
      "successColor=\\$(echo -en '\\033[01;32m')",
      "norm=\\$(echo -en '\\033[0m')",
      "",
      "#Function: parseOptions()",
      "#",
      "#Brief: Checks if all options are correct and saves them to variables",
      "#",
      "#Arguments all bash options",
      "parseOptions() {",
      "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
      "",
      "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
      "            printHelp",
      "        fi",
      "        shift",
      "    done",
      "",
      "}",
      "",
      "parseOptions \"\\$@\"",
      "",
      "echo \"Hello \\${cyanColor}bash\\${norm} world\"",
      ""
    ],
    "description": "Boilerplate simple Hello bash world"
  },
  "Boilerplate, simple one option": {
    "prefix": "Boilerplate 2",
    "body": [
      "#!/bin/bash\n",
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    echo \"  ${1:Description}\"",
      "    echo ",
      "    echo \"OPTIONS        Option description\"",
      "    echo \"  -help        Prints this help page\"",
      "    echo \"  -${2:express}     \"",
      "    echo",
      "    exit 0",
      "}",
      "",
      "#Text Color commands",
      "#Brief: Commands to change the color of a text",
      "highlight=\\$(echo -en '\\033[01;37m')",
      "purpleColor=\\$(echo -en '\\033[01;35m')",
      "cyanColor=\\$(echo -en '\\033[01;36m')",
      "errorColor=\\$(echo -en '\\033[01;31m')",
      "warningColor=\\$(echo -en '\\033[00;33m')",
      "successColor=\\$(echo -en '\\033[01;32m')",
      "norm=\\$(echo -en '\\033[0m')",
      "",
      "#Function: parseOptions()",
      "#",
      "#Brief: Checks if all options are correct and saves them to variables",
      "#",
      "#Arguments all bash options",
      "parseOptions() {",
      "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
      "",
      "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
      "            printHelp",
      "        elif [[ \"\\$1\" = \"-$2\" ]]; then ${2/(.*)/${1:/upcase}/}=\"true\"",
      "        else",
      "            echo \"Invalid option:  \\${errorColor}\\$1\\${norm}, get help by running command: \\$0 --help\"",
      "            exit 1",
      "        fi",
      "        ",
      "        shift",
      "    done",
      "",
      "}",
      "",
      "${2/(.*)/${1:/upcase}/}=\"false\"",
      "parseOptions \"\\$@\"",
      "",
      "echo \"Hello world ${2/(.*)/${1:/upcase}/}=\\${highlight}\\$${2/(.*)/${1:/upcase}/}\\${norm}\"",
      ""
    ],
    "description": "Boilerplate bash script with help that accepts one optional parameter"
  },
  "Boilerplate, one option, one option argument": {
      "prefix": "Boilerplate 3",
      "body": [
        "#!/bin/bash",
        "",
        "#true or false options.",
        "options=( \"-h\" \"--help\" \"-${1:express}\" ) ",
        "",
        "#Options that must be followed with one argument",
        "optionsWithArgument=( \"-${2:source}\" ) ",
        "",
        "#Options that must be provided by the user",
        "optionsRequired=( ${3:\"-$1\"  \"-$2\"} ) ",
        "",
        "#Set to true you want to allow any arguments to be given",
        "#Set to false if you only want to allow options in  \"options\" and \"optionsWithArgument\"",
        "ALLOW_UNPROCESSED=\"${4|true,false|}\" ",
        "",
        "printHelp() {",
        "    printf 'Usage: %s [OPTIONS]...\\\\n' \"\\$(basename \"\\$0\")\"",
        "    printf 'Usage: %s [OPTIONS]... (-$2 <$8>)\\\\n' \"\\$(basename \"\\$0\")\"",
        "    echo \"  ${5:What does you script do?}\"",
        "    echo ",
        "    echo \"OPTIONS         Option description\"",
        "    echo \"  --help        Prints this help page\"",
        "    echo \"  -$1    ${6:What does $1 represent?} \"",
        "    echo \"  -$2    ${7:What does $2 represent?} \"",
        "    echo",
        "    echo \"ARGUMENTS     Option argument description\"",
        "    echo \" ${8:$2Value}     ${9:Describe $8 in more detail!}\"",
        "    echo",
        "    exit 0",
        "}",
        "",
        "#Text Color commands",
        "#Brief: Commands to change the color of a text",
        "highlight=\\$(echo -en '\\\\033[01;37m')",
        "purpleColor=\\$(echo -en '\\\\033[01;35m')",
        "cyanColor=\\$(echo -en '\\\\033[01;36m')",
        "errorColor=\\$(echo -en '\\\\033[01;31m')",
        "warningColor=\\$(echo -en '\\\\033[00;33m')",
        "successColor=\\$(echo -en '\\\\033[01;32m')",
        "norm=\\$(echo -en '\\\\033[0m')",
        "",
        "#Function: parseOptions()",
        "#",
        "#Brief: Checks if all options are correct and saves each in a variable.",
        "#After: Value of each options given, is stored in a uppercase named variable.",
        "#       f. example -express will be stored in a global variable called EXPRESS",
        "#Returns:",
        "#      0 : (success) All paramters are valid",
        "#      1 : (error) One or more parameters are invalid",
        "#",
        "# Usage: parseOptions  (-opts <stringArray>) [string]...",
        "#        parseOptions  (-optsArg <stringArray>) [string]...",
        "#        parseOptions  (-opts <stringArray> -optsArg <stringArray>) [string]...",
        "#        parseOptions  (-opts <stringArray> -optsReq <stringArray>) [string]...",
        "#        parseOptions  (-optsArg <stringArray> -optsReq <stringArray>) [string]...",
        "#        parseOptions  (-opts <stringArray> -optsArg <stringArray> -optsReq <stringArray>) [string]...",
        "# Options     Option description",
        "#   -opts     Array of options",
        "#   -optsArg  Array of options which take one argument",
        "#   -optsReq  Array of required options",
        "# Arguments      Argument description",
        "#   stringArray  Array of options, where each option starts with '-'",
        "#   string       Any string",
        "#",
        "declare -a UNPROCESSED",
        "parseOptions() {",
        "    containsElement() { #if function arrayContains exists, it can be used instead of containsElement",
        "        local e match=\"\\$1\"",
        "        shift",
        "        for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
        "        return 1",
        "    }",
        "",
        "    if [[ \"\\$1\" == \"-opts\" ]]; then",
        "        shift",
        "        declare -a _options=(\"\\${!1}\")",
        "         if [ \\${#_options[@]} -eq 0 ]; then echo \"\\${errorColor}No options provided\\${norm}, quitting\"; exit 1; fi",
        "        shift",
        "    fi",
        "    if [[ \"\\$1\" == \"-optsArg\" ]]; then",
        "        shift",
        "        declare -a _optionsWithArgument=(\"\\${!1}\")",
        "        if [ \\${#_optionsWithArgument[@]} -eq 0 ]; then echo \"\\${errorColor}No options with arguments provided\\${norm}, quitting\"; exit 1; fi",
        "        shift",
        "    fi",
        "    if [[ \"\\$1\" == \"-optsReq\" ]]; then",
        "        shift",
        "        declare -a _optionsRequired=(\"\\${!1}\")",
        "        shift",
        "        ",
        "    fi",
        "",
        "    declare -a  _optionsFound",
        "    declare tmp tmpName",
        "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
        "        if containsElement \"\\$1\" \"\\${_options[@]}\"; then",
        "            #removing prefix - and -- and assigning value to uppercased variable.",
        "            _optionsFound+=(\"\\$1\")",
        "            tmp=\\${1#\"-\"};tmp=\\${tmp#\"-\"};tmp=\\$( echo \"\\$tmp\" | tr a-z A-Z )",
        "            printf -v \"\\$tmp\" \"true\"",
        "        elif containsElement \"\\$1\" \"\\${_optionsWithArgument[@]}\"; then",
        "            #removing prefix - and -- and assigning value to uppercased variable.",
        "            _optionsFound+=(\"\\$1\")",
        "            tmpName=\\$1",
        "            tmp=\\${1#\"-\"};tmp=\\${tmp#\"-\"};tmp=\\$( echo \"\\$tmp\" | tr a-z A-Z )",
        "            shift",
        "            if [[ -z \"\\$1\" ]];then echo \"Value missing for \\$tmpName\";return 1; fi",
        "            printf -v \"\\$tmp\" \"\\$1\"",
        "        else",
        "            if [[ \"\\$ALLOW_UNPROCESSED\" == \"true\" ]]; then",
        "                UNPROCESSED+=(\"\\$1\")",
        "                _optionsFound+=(\"\\$1\")",
        "            else",
        "                echo \"\\${errorColor}Error: \\${highlight}\\$1\\${norm} is an invalid argument.\"",
        "                return 1",
        "            fi",
        "        fi",
        "        shift",
        "    done",
        "",
        "    if [[ \"\\${_optionsRequired[*]}\" == \"0\" ]]; then return 0; fi;",
        "    #Check if all required options have been provided.",
        "    for arg in \"\\${_optionsRequired[@]}\"; do",
        "        if ! containsElement \"\\$arg\" \"\\${_optionsFound[@]}\"; then",
        "            echo  \"\\${errorColor}Required option missing \\${norm} \\$arg \"",
        "            return 1",
        "        fi",
        "    done",
        "}",
        "",
        "# You could test code below by running this script with these Arguments",
        "#   ./thisScript.sh -$1 -$3 ~/Downloads -weird",
        "if ! parseOptions -opts \"options[@]\" -optsArg \"optionsWithArgument[@]\" -optsReq \"optionsRequired[@]\" \"\\$@\"; then exit 1; fi",
        "if [[ -n \"\\$HELP\" || -n \"\\$H\" ]]; then printHelp; fi",
        "if [[ -n \"\\$${1/(.*)/${1:/upcase}/}\" ]]; then echo \"-$1=\\\"\\$${1/(.*)/${1:/upcase}/}\\\"\"; fi",
        "if [[ -n \"\\$${2/(.*)/${1:/upcase}/}\" ]]; then echo \"-$2=\\\"\\$${2/(.*)/${1:/upcase}/}\\\"\"; fi",
        "",
        "for arg in \"\\${UNPROCESSED[@]}\"; do",
        "    echo  \"\\${warningColor}Unprocessed argument\\${norm} \\$arg \"",
        "done",
        "",
        ""
      ],
      "description": "Boilerplate with one option and one option which requires a argument"
  },
  "Check if all options are valid and saves each in a variable": {
    "prefix": "parseOptions",
    "body": [
      "#Function: parseOptions()",
      "#",
      "#Brief: Checks if all options are correct and saves each in a variable.",
      "#After: Value of each options given, is stored in a uppercase named variable.",
      "#       f. example -express will be stored in a global variable called EXPRESS",
      "#Returns:",
      "#      0 : (success) All paramters are valid",
      "#      1 : (error) One or more parameters are invalid",
      "#",
      "# Usage: parseOptions  (-opts <stringArray>) [string]...",
      "#        parseOptions  (-optsArg <stringArray>) [string]...",
      "#        parseOptions  (-opts <stringArray> -optsArg <stringArray>) [string]...",
      "#        parseOptions  (-opts <stringArray> -optsReq <stringArray>) [string]...",
      "#        parseOptions  (-optsArg <stringArray> -optsReq <stringArray>) [string]...",
      "#        parseOptions  (-opts <stringArray> -optsArg <stringArray> -optsReq <stringArray>) [string]...",
      "# Options     Option description",
      "#   -opts     Array of options",
      "#   -optsArg  Array of options which take one argument",
      "#   -optsReq  Array of required options",
      "# Arguments      Argument description",
      "#   stringArray  Array of options, where each option starts with '-'",
      "#   string       Any string",
      "#",
      "declare -a UNPROCESSED",
      "parseOptions() {",
      "    containsElement() { #if function arrayContains exists, it can be used instead of containsElement",
      "        local e match=\"\\$1\"",
      "        shift",
      "        for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
      "        return 1",
      "    }",
      "",
      "    if [[ \"\\$1\" == \"-opts\" ]]; then",
      "        shift",
      "        declare -a _options=(\"\\${!1}\")",
      "         if [ \\${#_options[@]} -eq 0 ]; then echo \"Error: No options provided, quitting\"; exit 1; fi",
      "        shift",
      "    fi",
      "    if [[ \"\\$1\" == \"-optsArg\" ]]; then",
      "        shift",
      "        declare -a _optionsWithArgument=(\"\\${!1}\")",
      "        if [ \\${#_optionsWithArgument[@]} -eq 0 ]; then echo \"Error: No options with arguments provided, quitting\"; exit 1; fi",
      "        shift",
      "    fi",
      "    if [[ \"\\$1\" == \"-optsReq\" ]]; then",
      "        shift",
      "        declare -a _optionsRequired=(\"\\${!1}\")",
      "        shift",
      "        ",
      "    fi",
      "",
      "    declare -a  _optionsFound",
      "    declare tmp tmpName",
      "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
      "        if containsElement \"\\$1\" \"\\${_options[@]}\"; then",
      "            #removing prefix - and -- and assigning value to uppercased variable.",
      "            _optionsFound+=(\"\\$1\")",
      "            tmp=\\${1#\"-\"};tmp=\\${tmp#\"-\"};tmp=\\$( echo \"\\$tmp\" | tr a-z A-Z )",
      "            printf -v \"\\$tmp\" \"true\"",
      "        elif containsElement \"\\$1\" \"\\${_optionsWithArgument[@]}\"; then",
      "            #removing prefix - and -- and assigning value to uppercased variable.",
      "            _optionsFound+=(\"\\$1\")",
      "            tmpName=\\$1",
      "            tmp=\\${1#\"-\"};tmp=\\${tmp#\"-\"};tmp=\\$( echo \"\\$tmp\" | tr a-z A-Z )",
      "            shift",
      "            if [[ -z \"\\$1\" ]];then echo \"Value missing for \\$tmpName\";return 1; fi",
      "            printf -v \"\\$tmp\" \"\\$1\"",
      "        else",
      "            if [[ \"\\$ALLOW_UNPROCESSED\" == \"true\" ]]; then",
      "                UNPROCESSED+=(\"\\$1\")",
      "                _optionsFound+=(\"\\$1\")",
      "            else",
      "                echo \"Error: Error: \\${highlight}\\$1 is an invalid argument.\"",
      "                return 1",
      "            fi",
      "        fi",
      "        shift",
      "    done",
      "",
      "    if [[ \"\\${_optionsRequired[*]}\" == \"0\" ]]; then return 0; fi;",
      "    #Check if all required options have been provided.",
      "    for arg in \"\\${_optionsRequired[@]}\"; do",
      "        if ! containsElement \"\\$arg\" \"\\${_optionsFound[@]}\"; then",
      "            echo  \"Error: Required option missing  \\$arg \"",
      "            return 1",
      "        fi",
      "    done",
      "}"
    ],
    "description": "Check if all options are valid and saves each in a variable"
  },
  "Only allow super user to run this script": {
    "prefix": "IsSuper",
    "body": [
      "if (($EUID != 0)); then",
      "    echo \"Error: This command has to be run with superuser privileges (under the root user on most systems).\"",
      "    exit 1",
      "fi"
    ],
    "description": "Only allow super user to run this script"
  },

  "Frame your text": {
    "prefix": "frame",
    "body": [
      "#Function: frame()",
      "#",
      "#Brief: Writes pretty frame around provide text to the terminal",
      "#",
      "# Usage frame [OPTION]... <text>",
      "# OPTIONS",
      "#  --     The frame will drawn with a single line",
      "#  -=     The frame will drawn with a double line",
      "#  -c     The frame will be drawn with provided character.  This option must be ",
      "#         followed be the character to be used for drawing the frame surrounding",
      "#         frame. b Sometimes you will need to double quote this character, ",
      "#         For example for * you will need to double quote like this \"*\".",
      "#  -t     Only top part of the frame will be printed <text> will be ignored",
      "#  -b     Only the bottom part of the frame will be printed <text> will be ignored",
      "#  -m     Only provided text will be printed with surrounding frame sides",
      "#  -l     Provided <text> should be left aligned",
      "#  -r     Provided <text> should be right aligned",
      "#  -f     If provided the next parameter must contain the",
      "#         formatting to be used on the text inside the frame.",
      "#  -line  Print a horizontal line, <text> will be ignored",
      "#  -dLine Print a horizontal dashed line, <text> will be ignored",
      "#  -w     If provided the next parameter must contain a number representing how",
      "#         wide you want the surrounding frame to be, by default this number is 80.",
      "#",
      "#Please remember to double quote all parameters",
      "#example on how to write a blue text with double quoted frame around it:",
      "#  frame  -c = -f \\$(echo -en '\\033[01;34m') \"I am blue text\"",
      "#example on how to align many lines within one frame",
      "#  frame -w 50 -t",
      "#  frame -w 50 -m \"I am left aligned with no space\" -l",
      "#  frame -w 50 -m \"I am centered text\"",
      "#  frame -w 50 -m \" I am right aligned with 5 spaces     \" -r",
      "#  frame -w 50 -b",
      "frame() {",
      "    declare align='center'; #Alignment for text inside the frame",
      "    declare format;         #Text formatting",
      "    declare parts=\"all\";    #Print frame part- top, lower, middle or all parts.",
      "    declare box=\"-\";        #character(s) surrounding the text which will make the frame.",
      "    declare width=\"80\";     #The frame width",
      "    declare text;",
      "    declare normal=\\$(echo -en '\\033[0m')",
      "",
      "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
      "        ",
      "        if [[ \"\\$1\" = \"--\" ]]; then",
      "           box=\"-\"",
      "        elif [[ \"\\$1\" = \"-=\" ]]; then",
      "           box=\"=\"",
      "        elif [[ \"\\$1\" = \"-t\" ]]; then",
      "            parts=\"top\";",
      "        elif [[ \"\\$1\" = \"-m\" ]]; then",
      "            parts=\"middle\";",
      "        elif [[ \"\\$1\" = \"-b\" ]]; then",
      "            parts=\"bottom\";",
      "        elif [[ \"\\$1\" = \"-l\" ]]; then",
      "            align=\"left\";",
      "        elif [[ \"\\$1\" = \"-line\" ]]; then",
      "            echo -n \"├\"; printf '─%.0s' \\$(seq \\$((\\$width - 2)) ); echo \"┤\"; return",
      "        elif [[ \"\\$1\" = \"-dLine\" ]]; then",
      "            echo -n \"│\"; printf -- '-%.0s' \\$(seq \\$((\\$width - 2)) ); echo \"│\"; return",
      "        elif [[ \"\\$1\" = \"-r\" ]]; then",
      "            align=\"right\";",
      "        elif [[ \"\\$1\" = \"-c\" ]]; then",
      "           #We will need string of length 1 next",
      "           shift;",
      "            if [[ -z \\$1 || -n \\$1 && \\${#1} -ne 1 ]]; then echo \"Option -c will need to be followed by a character\" ; exit 1; fi;",
      "            box=\"\\$1\"",
      "        elif [[ \"\\$1\" = \"-w\" ]]; then",
      "           #We will need string of length 1 next",
      "           shift;",
      "           re='^[0-9]+\\$'",
      "            if ! [[  \"\\$1\" =~ \\$re ]] ; then echo \"Option -w will need to be followed by a number\" ; exit 1; fi;",
      "            width=\"\\$1\"",
      "        elif [[ \"\\$1\" = \"-f\" ]]; then",
      "           shift;",
      "           #We will need the formatting string next",
      "            if [ -z \\$1 ]; then echo \"Formatting option provided but formatting value missing!\" ; exit 1; fi;",
      "            format=\"\\$1\"",
      "        else",
      "            text=\"\\$1\"",
      "        fi",
      "        shift",
      "    done",
      "    if [[ -z \"\\$text\" &&  ( \"\\$parts\" != \"top\" && \"\\$parts\" != \"bottom\"  ) ]]; then echo \"Error No text Provided\"; exit 1; fi;",
      "        declare char=\"\\$box\"",
      "        declare side=\"\\$box\"",
      "        declare upLeft=\"\\$box\"",
      "        declare upRight=\"\\$box\"",
      "        declare downLeft=\"\\$box\"",
      "        declare downRight=\"\\$box\"",
      "    if [[ \"\\$box\" = \"=\" ]]; then",
      "        char=\"═\"",
      "        side=\"║\"",
      "        upLeft=\"╔\"",
      "        upRight=\"╗\"",
      "        downLeft=\"╚\"",
      "        downRight=\"╝\"",
      "    elif [[ \"\\$box\" = \"-\" ]]; then",
      "        char=\"─\"",
      "        side=\"│\"",
      "        upLeft=\"┌\"",
      "        upRight=\"┐\"",
      "        downLeft=\"└\"",
      "        downRight=\"┘\"",
      "    fi",
      "    STRING=\\$text",
      "    size=\\$(((\\$((width - 2)) - (\\${#STRING})) / 2))",
      "    str=\"%0.s\\$char\"",
      "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"top\" ]]; then",
      "        echo -en \"\\$upLeft\"",
      "        printf \\$str \\$(seq 1 \\$((width - 2)))",
      "        printf \"\\$upRight\\n\"",
      "    fi",
      "    pad=\\$(printf '%*s' \"\\$size\")",
      "    ",
      "    if [ \\$((\\${#STRING} % 2)) -eq 0 ]; then pad2=\"\\${pad}\"; else pad2=\"\\${pad} \"; fi",
      "    ",
      "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"middle\" ]]; then",
      "        if [[ \"\\$align\" = \"left\" ]]; then",
      "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
      "            pad=\\$(printf '%*s' \"\\$size\")",
      "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
      "            echo -e \"\\$side\\$STRING\\$pad\\$side\"",
      "        elif [[ \"\\$align\" = \"right\" ]]; then",
      "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
      "            pad=\\$(printf '%*s' \"\\$size\")",
      "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
      "            echo -e \"\\$side\\$pad\\$STRING\\$side\"",
      "        else",
      "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
      "            echo -e \"\\$side\\$pad\\$STRING\\$pad2\\$side\"",
      "        fi",
      "    fi",
      "    #normal",
      "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"bottom\" ]]; then",
      "        printf \"\\$downLeft\"",
      "        printf \\$str \\$(seq 1 \\$((width - 2)))",
      "        printf \"\\$downRight\\n\"",
      "    fi",
      "}",
      "",
      "frame \"I am a looking good title\""
    ],
    "description": "Frame your text"
  },
  "Select pre defined option": {
    "prefix": "menuOptions",
    "body": [
      "# Renders a text based list of options that can be selected by the",
      "# user using up, down and enter keys and returns the chosen option.",
      "#",
      "#   Arguments   : list of options, maximum of 256",
      "#                 \"opt1\" \"opt2\" ...",
      "#   Return value: selected index (0 for opt1, 1 for opt2 ...)",
      "function menuOption {",
      "",
      "    # little helpers for terminal print control and key input",
      "    ESC=\\$( printf \"\\033\")",
      "    cursor_blink_on()  { printf \"\\$ESC[?25h\"; }",
      "    cursor_blink_off() { printf \"\\$ESC[?25l\"; }",
      "    cursor_to()        { printf \"\\$ESC[\\$1;\\${2:-1}H\"; }",
      "    print_option()     { printf \"   \\$1 \"; }",
      "    print_selected()   { printf \"  \\$ESC[7m \\$1 \\$ESC[27m\"; }",
      "    get_cursor_row()   { IFS=';' read -sdR -p \\$'\\E[6n' ROW COL; echo \\${ROW#*[}; }",
      "    key_input()        { read -s -n3 key 2>/dev/null >&2",
      "                         if [[ \\$key = \\$ESC[A ]]; then echo up;    fi",
      "                         if [[ \\$key = \\$ESC[B ]]; then echo down;  fi",
      "                         if [[ \\$key = \"\"     ]]; then echo enter; fi; }",
      "",
      "    # initially print empty new lines (scroll down if at bottom of screen)",
      "    for opt; do printf \"\\n\"; done",
      "",
      "    # determine current screen position for overwriting the options",
      "    local lastrow=`get_cursor_row`",
      "    local startrow=\\$((\\$lastrow - \\$#))",
      "",
      "    # ensure cursor and input echoing back on upon a ctrl+c during read -s",
      "    trap \"cursor_blink_on; stty echo; printf '\\n'; exit\" 2",
      "    cursor_blink_off",
      "",
      "    local selected=0",
      "    while true; do",
      "        # print options by overwriting the last lines",
      "        local idx=0",
      "        for opt; do",
      "            cursor_to \\$((\\$startrow + \\$idx))",
      "            if [ \\$idx -eq \\$selected ]; then",
      "                print_selected \"\\$opt\"",
      "            else",
      "                print_option \"\\$opt\"",
      "            fi",
      "            ((idx++))",
      "        done",
      "",
      "        # user key control",
      "        case `key_input` in",
      "            enter) break;;",
      "            up)    ((selected--));",
      "                   if [ \\$selected -lt 0 ]; then selected=\\$((\\$# - 1)); fi;;",
      "            down)  ((selected++));",
      "                   if [ \\$selected -ge \\$# ]; then selected=0; fi;;",
      "        esac",
      "    done",
      "",
      "    # cursor position back to normal",
      "    cursor_to \\$lastrow",
      "    #printf \"\\n\"",
      "    cursor_blink_on",
      "",
      "    return \\$selected",
      "}",
      "",
      "#How to use this menu",
      "",
      "while true; do",
      "    options=(\"first option\" \"second option\" \"third option\" \"exit\")",
      "    menuOption \"\\${options[@]}\"",
      "    choice=\\$?",
      "    case \\$choice in",
      "    0)",
      "        echo \"First option was selected\";;",
      "    1) ",
      "        echo \"Second option was selected\";;",
      "    2)",
      "        echo \"Third option was selected\";;",
      "    3) ",
      "        echo \"exit selected\"",
      "        exit 0;;",
      "    esac",
      "",
      "    echo \"Chosen index = \\\"\\$choice\\\" value=\\\"\\${options[\\$choice]}\\\"\"",
      "    sleep 2.5",
      "done\n"
    ],
    "description": "Select pre defined option"
  },
  "Searches for an string within an array of strings": {
    "prefix": "arrayContains",
    "body": [
      "#Function: arrayContains()",
      "#",
      "#Brief: Searches for an string within an array of strings",
      "#",
      "#Argument 1(\\$1): String to search for",
      "#Argument 2(\\$2): Array of strings",
      "#Returns",
      "#       0 if found",
      "#       1 if not found",
      "#Example:",
      "#  flags=(\"-reset\" \"-express\" \"-source\")",
      "#   if arrayContains \"-express\" \"\\${flags[@]}\"; then",
      "#      echo \"String was found\"",
      "#   else",
      "#       echo \"String not found!\"",
      "#   fi",
      "arrayContains() {",
      "    local e match=\"\\$1\"",
      "    shift",
      "    for e; do [[ \"\\$e\" == \"\\$match\" ]] && return 0; done",
      "    return 1",
      "}\n"
    ],
    "description": "Searches for an string within an array of strings"
  },
  "For number loop": {
    "prefix": "for number",
    "body": [
        "for (( i=0; i<10; i++ )); do",
        " echo -n \"\\$i \"",
        "done\n"
    ],
    "description": "For loop with a number condition variable"
},
"For number in braces": {
  "prefix": "for number braces",
  "body": [
      "for i in {1..10}",
      "do",
      "    echo -n \"\\$i \"",
      "done\n"
  ],
  "description": "For loop with brace expancion"
},
"Case Example": {
  "prefix": "case example",
  "body": [
      "ANIMAL=\"cat\"",
      "echo -n \"\\$ANIMAL is \"",
      "case \\$ANIMAL in ",
      "    hawk)",
      "        echo \"a bird\"",
      "        ;;",
      "    dog|cat) ",
      "        echo \"a pet\"",
      "        ;;",
      "    *)",
      "      echo \"unknown\"",
      "        ;;",
      "esac"
  ],
  "description": "Case Statement Example"

},
"Case": {
  "prefix": "case",
  "body": [
      "case $1 in ",
      "    ${2:hawk})",
      "        ${3:echo \"a bird\"}",
      "        ;;",
      "    ${4:dog|cat}) ",
      "        ${5:echo \"a pet\"}",
      "        ;;",
      "    *)",
      "      ${6:echo \"unknown\"}",
      "        ;;",
      "esac\n"
  ],
  "description": "Case statement"
}
}
