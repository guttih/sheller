{
  "Text Color commands": {
    "prefix": "TextColors",
    "body": [
      "#Text Color commands",
      "#",
      "#Brief: Commands to change the color of a text",
      "highlight=\\$(echo -en '\\033[01;37m')",
      "purpleColor=\\$(echo -en '\\033[01;35m')",
      "cyanColor=\\$(echo -en '\\033[01;36m')",
      "errorColor=\\$(echo -en '\\033[01;31m')",
      "successColor=\\$(echo -en '\\033[01;32m')",
      "norm=\\$(echo -en '\\033[0m')",
      "",
      "echo \"Example color variations: \\${highlight}higlight\\${norm} text, \\${errorColor}error\\${norm} text, \\${successColor}success\\${norm} text, \\${purpleColor}purple\\${norm} text or \\${cyanColor}cyan\\${norm} text.\"",
      ""
    ],
    "description": "Text Color commands"
  },
  "Function": {
    "prefix": "func",
    "body": [
      "#Function: $1()",
      "#",
      "#Brief: $2",
      "#",
      "$1(){",
      "    $3",
      "}"
    ],
    "description": "Function description which takes no argument"
  },
  "Function 1 arguments": {
    "prefix": "func_1",
    "body": [
      "#Function: $1()",
      "#",
      "#Brief: $2",
      "#",
      "#Argument 1(\\$1): $3",
      "$1(){",
      "    if [ $# -ne 1 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
      "    $4",
      "}"
    ],
    "description": "Function description which takes 1 argument"
  },
  "Function 2 arguments": {
    "prefix": "func_2",
    "body": [
      "#Function: $1()",
      "#",
      "#Brief: $2",
      "#",
      "#Argument 1(\\$1): $3",
      "#Argument 2(\\$2): $4",
      "$1(){",
      "    if [ $# -ne 2 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
      "    $5",
      "}"
    ],
    "description": "Function description which takes 2 argument"
  },
  "Function 3 arguments": {
    "prefix": "func_3",
    "body": [
      "#Function: $1()",
      "#",
      "#Brief: $2",
      "#",
      "#Argument 1(\\$1): $3",
      "#Argument 2(\\$2): $4",
      "#Argument 3(\\$3): $5",
      "$1(){",
      "    if [ $# -ne 3 ]; then echo \"Invalid number of parameters\"; exit 1; fi",
      "    $6",
      "}"
    ],
    "description": "Function description which takes 3 argument"
  },
  "Print bash help": {
    "prefix": "printHelp",
    "body": [
      "printHelp() {",
      "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
      "    echo \"  ${1:Description}\"",
      "    echo ",
      "    echo \"OPTIONS\"",
      "    echo \"  -help        Prints this help page\"",
      "    echo \"  -$2     \"",
      "    echo",
      "}",
      "",
      "if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then printHelp; exit; fi",
      ""
    ],
    "description": "Create help for the bash script"
  },
  "Start of bash": {
    "prefix": "bash",
    "body": [
      "#!/bin/bash",
      ""
    ],
    "description": "Start of bash"
  },
  "Check if all options are correct ": {
    "prefix": "parseOptions",
    "body": [
      "#Function: parseOptions()",
      "#",
      "#Brief: Checks if all options are correct and saves them to variables",
      "#",
      "#Arguments all bash options",
      "parseOptions() {",
      "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
      "",
      "        if [[ \"\\$1\" != \"-${1:express}\" && \"\\$1\" != \"--help\" && \"\\$1\" != \"-h\" ]]; then",
      "            echo \"Invalid option \"\\$1\", get help by running command: \\$0 --help\"",
      "            exit 1",
      "        fi",
      "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
      "            printHelp",
      "            exit",
      "        fi",
      "        if [ \"\\$1\" = \"-$1\" ]; then PARAM_${1/(.*)/${1:/upcase}/}=\"true\"; fi",
      "        ",
      "        shift",
      "    done",
      "",
      "}",
      "",
      "PARAM_${1/(.*)/${1:/upcase}/}=\"false\"",
      "parseOptions \"\\$@\"",
      ""
    ],
    "description": "Check if all options are correct "
  },
  "Only allow super user to run this script": {
    "prefix": "IsSuper",
    "body": [
     "if (($EUID != 0)); then",
     "    echo \"Error: This command has to be run with superuser privileges (under the root user on most systems).\"",
     "    exit 1",
     "fi"
    ],
    "description": "Only allow super user to run this script"
     },
     "Bash Boilerplate": {
      "prefix": "bash_Boilerplate",
      "body": [
        "#!/bin/bash",
        "",
        "#Text Color commands",
        "#",
        "#Brief: Commands to change the color of a text",
        "highlight=\\$(echo -en '\\033[01;37m')",
        "purpleColor=\\$(echo -en '\\033[01;35m')",
        "cyanColor=\\$(echo -en '\\033[01;36m')",
        "errorColor=\\$(echo -en '\\033[01;31m')",
        "successColor=\\$(echo -en '\\033[01;32m')",
        "norm=\\$(echo -en '\\033[0m')",
        "",
        "printHelp() {",
        "    printf 'Usage: %s [OPTIONS]...\\n' \"$(basename \"\\$0\")\"",
        "    echo \"  ${1:Description}\"",
        "    echo ",
        "    echo \"OPTIONS        Option description\"",
        "    echo \"  -help        Prints this help page\"",
        "    echo \"  -${2:express}     \"",
        "    echo",
        "}",
        "",
        "#Function: parseOptions()",
        "#",
        "#Brief: Checks if all options are correct and saves them to variables",
        "#",
        "#Arguments all bash options",
        "parseOptions() {",
        "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
        "",
        "        if [[ \"\\$1\" != \"-$2\" && \"\\$1\" != \"--help\" && \"\\$1\" != \"-h\" ]]; then",
        "            echo \"Invalid option:  \\${errorColor}\\$1\\${norm}, get help by running command: \\$0 --help\"",
        "            exit 1",
        "        fi",
        "        if [[ \"\\$1\" == \"--help\" || \"\\$1\" == \"-h\" ]]; then",
        "            printHelp",
        "            exit",
        "        fi",
        "        if [ \"\\$1\" = \"-$2\" ]; then PARAM_${2/(.*)/${1:/upcase}/}=\"true\"; fi",
        "        ",
        "        shift",
        "    done",
        "",
        "}",
        "",
        "PARAM_${2/(.*)/${1:/upcase}/}=\"false\"",
        "parseOptions \"\\$@\"",
        "",
        "echo \"Hello world PARAM_${2/(.*)/${1:/upcase}/} \\${highlight}\\$PARAM_${2/(.*)/${1:/upcase}/}\\${norm}\"",
        ""
      ],
      "description": "Boilerplate bash script with help that accepts one optional parameter"
    },
    "Frame your text": {
      "prefix": "frame",
      "body": [
        "#Function: frame()",
        "#",
        "#Brief: Writes pretty frame around provied text to the terminal",
        "#",
        "# Usage frame [OPTION]... <text>",
        "# OPTIONS",
        "#  --    The frame will drawn with a single line",
        "#  -=    The frame will drawn with a double line",
        "#  -c    The frame will be drawn with provided character.  This option must be ",
        "#        followed be the character to be used for drawing the frame surrounding",
        "#        frame. b Sometimes you will need to double qoute this characther, ",
        "#        For example for * you will need to double qoute like this \"*\".",
        "#  -t    Only top part of the frame will be printed <text> will be ignored",
        "#  -b    Only the bottom part of the fram will be printed <text> will be ignored",
        "#  -m    Only provided text will be printed with surrounding frame sides",
        "#  -l    Provided <text> should be left aligned",
        "#  -r    Provided <text> should be right aligned",
        "#  -f    If provided the next parameter must contain the formatting to be used",
        "#        on the text inside the frame.",
        "#  -w    If provided the next parameter must contain a number representing how",
        "#        wide you want the surrouding frame to be, by default this number is 80.",
        "#",
        "#Please remember to double qoute all parameters",
        "#example on how to write a blue text with double quoted frame around it:",
        "#  frame  -c = -f \\$(echo -en '\\033[01;34m') \"I am blue text\"",
        "#example on how to align many lines within one frame",
        "#  frame -w 50 -t",
        "#  frame -w 50 -m \"I am left alligned with no space\" -l",
        "#  frame -w 50 -m \"I am centered text\"",
        "#  frame -w 50 -m \" I am right alligned with 5 spaces     \" -r",
        "#  frame -w 50 -b",
        "frame() {",
        "    declare align='center'; #Allignment for text inside the frame",
        "    declare format;         #Text formatting",
        "    declare parts=\"all\";    #Print frame part- top, lower, middle or all parts.",
        "    declare box=\"-\";        #character(s) surrounding the text which will make the frame.",
        "    declare width=\"80\";     #The frame width",
        "    declare text;",
        "    declare normal=\\$(echo -en '\\033[0m')",
        "",
        "    while ((\"\\$#\")); do # While there are arguments still to be shifted",
        "        ",
        "        if [[ \"\\$1\" = \"--\" ]]; then",
        "           box=\"-\"",
        "        elif [[ \"\\$1\" = \"-=\" ]]; then",
        "           box=\"=\"",
        "        elif [[ \"\\$1\" = \"-t\" ]]; then",
        "            parts=\"top\";",
        "        elif [[ \"\\$1\" = \"-m\" ]]; then",
        "            parts=\"middle\";",
        "        elif [[ \"\\$1\" = \"-b\" ]]; then",
        "            parts=\"bottom\";",
        "        elif [[ \"\\$1\" = \"-l\" ]]; then",
        "            align=\"left\";",
        "        elif [[ \"\\$1\" = \"-r\" ]]; then",
        "            align=\"right\";",
        "        elif [[ \"\\$1\" = \"-c\" ]]; then",
        "           #We will need string of length 1 next",
        "           shift;",
        "            if [[ -z \\$1 || -n \\$1 && \\${#1} -ne 1 ]]; then echo \"Option -c will need to be followed by a character\" ; exit 1; fi;",
        "            box=\"\\$1\"",
        "        elif [[ \"\\$1\" = \"-w\" ]]; then",
        "           #We will need string of length 1 next",
        "           shift;",
        "           re='^[0-9]+\\$'",
        "            if ! [[  \"\\$1\" =~ \\$re ]] ; then echo \"Option -w will need to be followed by a number\" ; exit 1; fi;",
        "            width=\"\\$1\"",
        "        elif [[ \"\\$1\" = \"-f\" ]]; then",
        "           shift;",
        "           #We will need the formatting string next",
        "            if [ -z \\$1 ]; then echo \"Formatting option provided but formatting value missing!\" ; exit 1; fi;",
        "            format=\"\\$1\"",
        "        else",
        "            text=\"\\$1\"",
        "        fi",
        "        shift",
        "    done",
        "    if [[ -z \"\\$text\" &&  ( \"\\$parts\" != \"top\" && \"\\$parts\" != \"bottom\"  ) ]]; then echo \"Error No text Provided\"; exit 1; fi;",
        "        declare char=\"\\$box\"",
        "        declare side=\"\\$box\"",
        "        declare upLeft=\"\\$box\"",
        "        declare upRight=\"\\$box\"",
        "        declare downLeft=\"\\$box\"",
        "        declare downRight=\"\\$box\"",
        "    if [[ \"\\$box\" = \"=\" ]]; then",
        "        char=\"═\"",
        "        side=\"║\"",
        "        upLeft=\"╔\"",
        "        upRight=\"╗\"",
        "        downLeft=\"╚\"",
        "        downRight=\"╝\"",
        "    elif [[ \"\\$box\" = \"-\" ]]; then",
        "        char=\"─\"",
        "        side=\"│\"",
        "        upLeft=\"┌\"",
        "        upRight=\"┐\"",
        "        downLeft=\"└\"",
        "        downRight=\"┘\"",
        "    fi",
        "    STRING=\\$text",
        "    size=\\$(((\\$((width - 2)) - (\\${#STRING})) / 2))",
        "    str=\"%0.s\\$char\"",
        "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"top\" ]]; then",
        "        echo -en \"\\$upLeft\"",
        "        printf \\$str \\$(seq 1 \\$((width - 2)))",
        "        printf \"\\$upRight\\n\"",
        "    fi",
        "    pad=\\$(printf '%*s' \"\\$size\")",
        "    ",
        "    if [ \\$((\\${#STRING} % 2)) -eq 0 ]; then pad2=\"\\${pad}\"; else pad2=\"\\${pad} \"; fi",
        "    ",
        "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"middle\" ]]; then",
        "        if [[ \"\\$align\" = \"left\" ]]; then",
        "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
        "            pad=\\$(printf '%*s' \"\\$size\")",
        "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
        "            echo -e \"\\$side\\$STRING\\$pad\\$side\"",
        "        elif [[ \"\\$align\" = \"right\" ]]; then",
        "            size=\\$(((\\$((width - 2)) - (\\${#STRING}))))",
        "            pad=\\$(printf '%*s' \"\\$size\")",
        "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
        "            echo -e \"\\$side\\$pad\\$STRING\\$side\"",
        "        else",
        "            if [[ -n \"\\$format\" ]]; then STRING=\"\\$format\\${STRING}\\${normal}\"; fi",
        "            echo -e \"\\$side\\$pad\\$STRING\\$pad2\\$side\"",
        "        fi",
        "    fi",
        "    #normal",
        "    if [[ \"\\$parts\" = \"all\" || \"\\$parts\" = \"bottom\" ]]; then",
        "        printf \"\\$downLeft\"",
        "        printf \\$str \\$(seq 1 \\$((width - 2)))",
        "        printf \"\\$downRight\\n\"",
        "    fi",
        "}",
        "",
        "frame \"I am a looking good title\""
      ],
      "description": "Frame your text"
    },"Select pre defined option": {
      "prefix": "menuOptions",
      "body": [
        "# Renders a text based list of options that can be selected by the",
        "# user using up, down and enter keys and returns the chosen option.",
        "#",
        "#   Arguments   : list of options, maximum of 256",
        "#                 \"opt1\" \"opt2\" ...",
        "#   Return value: selected index (0 for opt1, 1 for opt2 ...)",
        "function menuOption {",
        "",
        "    # little helpers for terminal print control and key input",
        "    ESC=\\$( printf \"\\033\")",
        "    cursor_blink_on()  { printf \"\\$ESC[?25h\"; }",
        "    cursor_blink_off() { printf \"\\$ESC[?25l\"; }",
        "    cursor_to()        { printf \"\\$ESC[\\$1;\\${2:-1}H\"; }",
        "    print_option()     { printf \"   \\$1 \"; }",
        "    print_selected()   { printf \"  \\$ESC[7m \\$1 \\$ESC[27m\"; }",
        "    get_cursor_row()   { IFS=';' read -sdR -p \\$'\\E[6n' ROW COL; echo \\${ROW#*[}; }",
        "    key_input()        { read -s -n3 key 2>/dev/null >&2",
        "                         if [[ \\$key = \\$ESC[A ]]; then echo up;    fi",
        "                         if [[ \\$key = \\$ESC[B ]]; then echo down;  fi",
        "                         if [[ \\$key = \"\"     ]]; then echo enter; fi; }",
        "",
        "    # initially print empty new lines (scroll down if at bottom of screen)",
        "    for opt; do printf \"\\n\"; done",
        "",
        "    # determine current screen position for overwriting the options",
        "    local lastrow=`get_cursor_row`",
        "    local startrow=\\$((\\$lastrow - \\$#))",
        "",
        "    # ensure cursor and input echoing back on upon a ctrl+c during read -s",
        "    trap \"cursor_blink_on; stty echo; printf '\\n'; exit\" 2",
        "    cursor_blink_off",
        "",
        "    local selected=0",
        "    while true; do",
        "        # print options by overwriting the last lines",
        "        local idx=0",
        "        for opt; do",
        "            cursor_to \\$((\\$startrow + \\$idx))",
        "            if [ \\$idx -eq \\$selected ]; then",
        "                print_selected \"\\$opt\"",
        "            else",
        "                print_option \"\\$opt\"",
        "            fi",
        "            ((idx++))",
        "        done",
        "",
        "        # user key control",
        "        case `key_input` in",
        "            enter) break;;",
        "            up)    ((selected--));",
        "                   if [ \\$selected -lt 0 ]; then selected=\\$((\\$# - 1)); fi;;",
        "            down)  ((selected++));",
        "                   if [ \\$selected -ge \\$# ]; then selected=0; fi;;",
        "        esac",
        "    done",
        "",
        "    # cursor position back to normal",
        "    cursor_to \\$lastrow",
        "    #printf \"\\n\"",
        "    cursor_blink_on",
        "",
        "    return \\$selected",
        "}",
        "",
        "#How to use this menu",
        "",
        "while true; do",
        "    options=(\"first option\" \"second option\" \"third option\" \"exit\")",
        "    menuOption \"\\${options[@]}\"",
        "    choice=\\$?",
        "    case \\$choice in",
        "    0)",
        "        echo \"First option was selected\";;",
        "    1) ",
        "        echo \"Second option was selected\";;",
        "    2)",
        "        echo \"Third option was selected\";;",
        "    3) ",
        "        echo \"exit selected\"",
        "        exit 0;;",
        "    esac",
        "",
        "    echo \"Choosen index = \\\"\\$choice\\\" value=\\\"\\${options[\\$choice]}\\\"\"",
        "    sleep 2.5",
        "done"
      ],
      "description": "Select pre defined option"
    }
}
